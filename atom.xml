<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ian的Blog小屋</title>
  
  <subtitle>好看的皮囊千篇一律，有趣的灵魂万里挑一</subtitle>
  <link href="http://ianblog.top/atom.xml" rel="self"/>
  
  <link href="http://ianblog.top/"/>
  <updated>2023-09-21T13:36:21.550Z</updated>
  <id>http://ianblog.top/</id>
  
  <author>
    <name>Ian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js——fs模块</title>
    <link href="http://ianblog.top/posts/95529e13.html"/>
    <id>http://ianblog.top/posts/95529e13.html</id>
    <published>2023-05-07T07:14:13.000Z</published>
    <updated>2023-09-21T13:36:21.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>的<code>fs</code>模块能够与文件系统进行交互。</p></blockquote><h2 id="fs模块介绍"><a href="#fs模块介绍" class="headerlink" title="fs模块介绍"></a><code>fs</code>模块介绍</h2><p><code>fs（File System）</code>是<code>Node.js</code>的内置模块，可以实现与硬盘的交互，例如文件的创建、删除、重命名、移动，以及文件的写入与读取。</p><p>下面我将介绍<code>fs</code>模块的基本操作：</p><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>将数据保存到文件中，我们平常下载文件、安装软件的时候，就是将文件写入了磁盘中。</p><h3 id="1-writeFile异步写入"><a href="#1-writeFile异步写入" class="headerlink" title="1. writeFile异步写入"></a>1. <code>writeFile</code>异步写入</h3><p>语法：<code>fs.writeFile(file, data[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>data</code></td><td>待写入的数据</td></tr><tr><td><code>options</code></td><td>配置选项</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello Node.js&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 失败传入错误对象，成功传入null</span></span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)；</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-writeFileSync同步写入"><a href="#2-writeFileSync同步写入" class="headerlink" title="2.writeFileSync同步写入"></a>2.<code>writeFileSync</code>同步写入</h3><p>语法：<code>fs.writeFile(file, data[, options])</code></p><p>说明：参数部分与异步写入一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于没有回调函数，所以使用try catch来捕获错误</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello, Node.js&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-appendFile-appendFileSync追加写入"><a href="#3-appendFile-appendFileSync追加写入" class="headerlink" title="3. appendFile/appendFileSync追加写入"></a>3. <code>appendFile/appendFileSync</code>追加写入</h3><p>同样分为同步追加写入和异步追加写入。</p><p>语法：</p><p><code>fs.appendFile(file, data[, options], callback)</code></p><p><code>fs.appendFileSync(file, data[, options])</code></p><p>说明：参数部分与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加失败&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;\r\nhello&#x27;</span>); <span class="comment">// \r\n换行操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-creatWriteStream流式写入"><a href="#4-creatWriteStream流式写入" class="headerlink" title="4. creatWriteStream流式写入"></a>4. <code>creatWriteStream</code>流式写入</h3><p>语法：<code> fs.createWriteStream(path[, options])</code></p><p>说明：参数含义仍然一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>); <span class="comment">// 创建写入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次写入操作</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;为有源头活水来\r\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ws.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>对比：流式写入方式适用于 <strong>大文件写入</strong>或者<strong>频繁写入</strong> 的场景, <code>writeFile </code>适合于 写入频率较低的场景</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>从文件中读取数据，平时电脑开机、程序运行、播放视频、查看图片都是在读取文件。</p><h3 id="1-readFile异步读取"><a href="#1-readFile异步读取" class="headerlink" title="1. readFile异步读取"></a>1. <code>readFile异步读取</code></h3><p>语法：<code> fs.readFile(path[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>options</code></td><td>配置对象</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以utf-8字符集读取</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-readFileSync同步读取"><a href="#2-readFileSync同步读取" class="headerlink" title="2.readFileSync同步读取"></a>2.<code>readFileSync同步读取</code></h3><p>语法：<code> fs.readFileSync(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> data2 = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-creatReadStream流式读取"><a href="#3-creatReadStream流式读取" class="headerlink" title="3. creatReadStream流式读取"></a>3. <code>creatReadStream流式读取</code></h3><p>语法：<code> fs.createReadStream(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次取出 64k 数据后执行一次 data 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">length</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取完毕后, 执行 end 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的fs模块。</summary>
    
    
    
    <category term="Node.js" scheme="http://ianblog.top/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——介绍</title>
    <link href="http://ianblog.top/posts/c222fd29.html"/>
    <id>http://ianblog.top/posts/c222fd29.html</id>
    <published>2023-05-05T08:15:14.000Z</published>
    <updated>2023-09-21T05:31:44.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>使<code>JavaScript</code>具有服务端开发的能力。</p></blockquote><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是<code>Node.js</code></h2><blockquote><p><code>Node.js</code>官方给出的定义是：</p><p><code>Node.js</code>® is an open-source, cross-platform JavaScript runtime environment.</p></blockquote><p>意思是：<code>Node.js</code>是一个开源的，跨平台的<code>JavaScript</code>运行环境。通俗地说，<code>Node.js</code>其实就是一款应用程序，能够运行<code>JavaScript</code>。</p><p>Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p><p><a href="https://nodejs.org/en">下载<code>Node.js</code> </a>，推荐安装LTS（长期支持版本）</p><p>检测是否下载成功，在命令行中输入<code>node -v</code>，如果显示出版本号了，则说明安装成功。</p><h2 id="Node-js的作用"><a href="#Node-js的作用" class="headerlink" title="Node.js的作用"></a><code>Node.js</code>的作用</h2><ol><li>开发服务器应用</li><li>开发工具类应用（<code>Webpack</code>、<code>Vite</code>、<code>Babel</code>）</li><li>开发桌面端应用（<code>VScode</code>、<code>Figma</code>、<code>Postman</code>都是借助<code>electron</code>开发的）</li></ol><h2 id="Node-js的使用"><a href="#Node-js的使用" class="headerlink" title="Node.js的使用"></a><code>Node.js</code>的使用</h2><p>使用<code>Node.js</code>运行<code>JavaScript</code>代码：</p><ol><li>在你的代码目录中新建一个文件<code>hello.js</code>，输入<code>console.log(&quot;hello, Node.js&quot;)</code>，保存。</li><li>然后打开<code>VScode</code>终端（如果你的代码编辑器是<code>VScode</code>的话），输入<code>node hello.js</code>。或者你也可以直接打开<code>cmd</code>，只不过需要切换为文件所在目录。</li><li>终端上显示<code>hello, Node.js</code>。</li></ol><p>注意点：</p><ul><li><code>Node.js</code>中的<code>API</code>与浏览器中的<code>API</code>有所区别，重点是不能在<code>Node.js</code>中使用<code>DOM</code>、<code>BOM</code> （如果你在<code>Node.js</code>中输出<code>window</code>对象或者<code>document</code>对象的话，会报错）。</li><li><code>Node.js</code>当中的顶级对象是<code>global</code>或者<code>globalThis</code>（<code>ES2020</code>定义）。</li><li><code>Nodde.js</code>使用的是<code>CommonJS</code>模块，所以导入模块方式为<code>const xxx = require(&#39;xxx&#39;)</code>。</li></ul>]]></content>
    
    
    <summary type="html">本文简单介绍了Node.js。</summary>
    
    
    
    <category term="Node.js" scheme="http://ianblog.top/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——状态码</title>
    <link href="http://ianblog.top/posts/9abd0c3c.html"/>
    <id>http://ianblog.top/posts/9abd0c3c.html</id>
    <published>2023-05-02T06:25:15.000Z</published>
    <updated>2023-09-21T02:40:54.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP的响应状态码多达几十种，本文仅介绍具有代表性的14种。本文基于图书《图解HTTP》。</p></blockquote><h2 id="状态码的作用"><a href="#状态码的作用" class="headerlink" title="状态码的作用"></a>状态码的作用</h2><p>首先了解以下，状态码指的是什么。当服务器返回响应时，在响应报文的响应行位置会有3位数字以及原因短语组成的状态码，例如 200 OK。</p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果、标记服务器端的处理是否正常、通知出现的错误等。</p><h2 id="状态码的分类"><a href="#状态码的分类" class="headerlink" title="状态码的分类"></a>状态码的分类</h2><p>状态码有五大类：</p><table><thead><tr><th></th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>1XX</td><td>Information（信息状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p>下面仅介绍代表性的14种：</p><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><p>2XX的响应结果表明请求被正常处理了。</p><ul><li><strong>200 OK</strong>表示从客户端发来的请求在服务器端被正常处理了。</li><li><strong>204 No Content</strong>表示服务器接收到的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</li><li><strong>206 Partial Content</strong>表示客户端进行了范围请求（Range Request），而服务器成功执行了这部分的GET请求。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>3XX的响应结果表明浏览器需要执行某些特殊的处理以正常处理请求。</p><ul><li><strong>301 Moved Permanently</strong>永久重定向，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI（响应中Location字段表明现在资源所处的URI）。</li><li><strong>302 Found</strong>临时重定向，表示请求的资源已被分配了新的URI，希望用户本次使用新的URi访问资源。</li><li><strong>303 See Other</strong>表示请求的资源存在着另一个URI，应使用<strong>GET</strong>方法定向获取请求的资源（请求方法会变为GET）。</li><li><strong>304 Not Modified</strong>表示客户端发送附带条件的请求（指的是采用GET方法的请求报文中包含了If-Match、If-Modified-Since等首部）时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器资源未改变，直接使用未过期的缓存）。</li><li><strong>307 Temporary Redirect</strong>临时重定向，与302类似，但是不会改变请求方法，例如不会从POST变成GET。</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><ul><li><strong>400 Bad Request</strong>表示请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li><li><strong>403 Forbidden</strong>表示对请求资源的访问被服务器拒绝了，例如未获得文件系统的访问权限等。</li><li><strong>404 Not Found</strong>表示服务器上无法找到请求的资源。</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX的响应结果表明服务器本身发生错误。</p><ul><li><strong>500 Internet Server Error</strong>表示服务器端在执行请求时发生了错误，可能出现了bug或者临时的故障。</li><li><strong>503 ServIce Unavailable</strong>表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><p>nice!😊！</p>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的常用的响应状态码</summary>
    
    
    
    <category term="HTTP协议" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——介绍</title>
    <link href="http://ianblog.top/posts/d5a386f7.html"/>
    <id>http://ianblog.top/posts/d5a386f7.html</id>
    <published>2023-04-28T02:12:13.000Z</published>
    <updated>2023-09-21T01:58:22.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP作为通信协议，被广泛用于客户端和服务端之间的通信流程。本文基于图书《图解HTTP》。</p></blockquote><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><blockquote><p><code>MDN</code>上对HTTP协议的解释是：<strong>HTTP</strong> 是一种用作获取诸如 HTML 文档这类资源的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>。</p></blockquote><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012?fromModule=lemma_inlink">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>事实上HTTP协议是<code>TCP/IP</code>协议族的一个子集，属于应用层面。那么你可能会有疑问：什么是<code>TCP/IP</code>协议族呢？</p><p>对于这个问题，要做详实的说明实在太难了，这里我只做简单说明一些知识。</p><h3 id="TCP-IP定义"><a href="#TCP-IP定义" class="headerlink" title="TCP&#x2F;IP定义"></a>TCP&#x2F;IP定义</h3><p>我们平常使用的网络就是在TCP&#x2F;IP协议族的基础上建立的。计算机与网络设备之间要相互通信，必须遵循相同的约定，比如说使用哪种语言、使用怎样的通信方式、通信的具体细节等。不同硬件、操作系统之间的通信，都需要相应的规则来进行约束，这种规则就称作协议。而TCP&#x2F;IP就是指的是互联网相关联的协议集合的总称。</p><h3 id="TCP-IP分层管理"><a href="#TCP-IP分层管理" class="headerlink" title="TCP&#x2F;IP分层管理"></a>TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族按层次分为4层，分别是应用层、传输层、网络层和数据链路层。通过分层，可以将各个职能拆分出来，比如说应用层就只关心分派给自己的任务，而不用关心传输线路与是否能传输到等问题。</p><ul><li><strong>应用层</strong>决定了向用户提供应用服务时通信的活动，处于该层的协议有FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）以及HTTP。</li><li><strong>传输层</strong>提供处于网络连接中的两台计算机之间的数据传输，处于该层的有TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</li><li><strong>网络层</strong>用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。处于该层的有IP（Internet Protocol，网际协议）。</li><li><strong>链路层</strong>用来处理连接网络的硬件部分。处于该层的有以太网协议。</li></ul><p>利用TCP&#x2F;IP进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层网上走。</p><h2 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h2><p>HTTP是一种不保存状态，即无状态协议。HTTP自身不对请求和响应之间的通信状态进行保存。</p><p><strong>PS：</strong>在HTTP&#x2F;1.1中为了实现保存状态的功能，引入了<code>Cookie</code>技术，Cookie相关的内容这里就不再赘述了，简而言之，就是服务器返回的用于标识客户端的信息。并且HTTP&#x2F;1.1也实现了持久连接（HTTP keep-alive），可以在建立一次TCP连接后进行多次请求。</p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP方法是用于告诉服务器该如何处理对应的资源。</p><p>以下方法来自HTTP&#x2F;1.1：（事实上，常用的方法就GET、POST）</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>用于请求访问已经被URI识别的资源。指定的资源经服务器端解析后返回 响应内容。</p><p>其报文形式为（现在看不懂没关系，后面会说明）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述请求将返回<code>index.html</code>的页面资源。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>用来传输实体的主体。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit.cgi</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">a</span>=<span class="number">1</span>&amp;b=<span class="number">2</span></span></span><br></pre></td></tr></table></figure><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>用来传输文件。需要配合验证，不然谁都可以进行文件上传。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560</span><br><span class="line"></span><br><span class="line"><span class="language-node-repl"><span class="meta prompt_">...</span></span></span><br></pre></td></tr></table></figure><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>用来获得报文首部。不返回响应报文主体部分，用于确认URI有效性及资源更新的日期时间等。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>用来删除文件，同样需要配合验证机制。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>用来查询针对请求URI指定资源支持的方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//请求  * 则是指对服务器进行查询</span><br><span class="line">OPTIONS * HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br><span class="line">// 响应</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span><span class="punctuation">: </span>GET,POST，HEAD，OPTIONS</span><br></pre></td></tr></table></figure><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>让Web服务器端将之前的请求通信返回给客户端的方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRACE</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span><br><span class="line"><span class="attribute">Max-Forwards</span><span class="punctuation">: </span>2</span><br></pre></td></tr></table></figure><p>响应部分</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>message/http</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1024</span><br><span class="line"></span><br><span class="line"><span class="language-http"><span class="keyword">TRACE</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span></span><br><span class="line"><span class="language-http"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span></span><br><span class="line"><span class="language-http"><span class="attribute">Max-Forwards</span><span class="punctuation">: </span>2</span></span><br></pre></td></tr></table></figure><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">proxy.def.com:8080</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nice!😊恭喜你完成了阅读！之后会继续介绍HTTP中常用的状态码、首部、Web攻击等知识。</p>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的一些基本概念</summary>
    
    
    
    <category term="HTTP协议" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的闭包</title>
    <link href="http://ianblog.top/posts/7ae5b853.html"/>
    <id>http://ianblog.top/posts/7ae5b853.html</id>
    <published>2023-04-23T06:42:36.000Z</published>
    <updated>2023-09-20T02:01:42.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包是<code>Javascript</code>中一个重要的特性，使用闭包可以实现特定的需求，例如函数柯里化等。想要弄懂闭包，首先得要对执行上下文和作用域有足够的了解。</p></blockquote><h1 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h1><p>简单来说，执行上下文就是<code>Javascript</code>代码执行的环境。每个上下文都有一个关联的变量对象，在这个上下文中定义的所有变量和函数都存在于这个变量对象上。</p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul><li><strong>全局上下文</strong> ：最外层的上下文，在浏览器中指的就是<code>window</code>对象，并且用var定义的全局变量和函数会成为<code>window</code>对象的属性和方法。一个程序中只会有一个全局上下文。</li><li><strong>函数上下文</strong> ：每个函数调用都有自己的上下文。函数上下文可以有任意多个。</li><li><strong><code>Eval()</code>调用内部上下文</strong> ：执行在<code>eval</code>函数内部的代码创建属于自己的上下文。</li></ul><p><code>ECAMScript</code> 程序执行流是通过上下文栈来控制的，当代码执行流进入函数时，函数上下文会被推入栈中，当函数执行完毕时，函数上下文会被弹出栈外，将控制权返还给之前的执行上下文。</p><h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>作用域是程序中定义变量的区域，它决定了当前代码对变量的访问权限。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">//  执行函数创建变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>说明：在<code>fn</code> 函数内部创建了一个变量<code>a</code> ，但是在全局访问的时候，系统报错。可见，全局是无法获取函数内部的变量。</p><h2 id="作用域的分类"><a href="#作用域的分类" class="headerlink" title="作用域的分类"></a>作用域的分类</h2><ul><li><p><strong>全局作用域</strong> ：在全局范围内声明的变量（<strong>特殊情况</strong>：在函数中不使用关键字声明变量也会成为全局变量）处于全局作用域下，可以在程序的任意地方访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">display</span>();  <span class="comment">//  打印 0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数作用域</strong> ：也称局部作用域，在函数内部声明的变量处于函数作用域下，不能再函数以外的位置访问（闭包除外）。</p></li><li><p><strong>块级作用域</strong> ：<code>ES6</code>引入的<code>let</code>和<code>const</code> 关键字在大括号中定义的变量处于块级作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  打印 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><code>JavaScript</code> 遵循的是词法作用域。词法作用域也称静态作用域，是指变量的作用域在创建时就确定好了，而不是执行时才确定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  输出 0</span></span><br></pre></td></tr></table></figure><p>上述代码执行<code>bar</code> 函数，输出的是0，而不是1，说明在<code>bar</code>中调用<code>foo</code> ，函数<code>foo</code> 是访问不到<code>bar</code> 内部的变量。因为<code>foo</code> 处在全局作用域中，而<code>bar</code> 中的变量<code>a</code>是处在函数作用域中。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>在上面，我们知道了处在不同作用域的代码具有不同的访问权限。但是我们还不清楚访问变量是什么样的流程，访问一个变量到底是遵循什么样的规则？当有多个同名的变量可供访问时，选取哪一个？这些问题需要借助作用域链来解决。</p></blockquote><p>上下文中的代码在执行时，会创建变量对象的一个<strong>作用域链</strong>。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。作用域链的顶端（也就是第一个变量对象）<strong>始终</strong>是代码正在执行的上下文，下一个变量对象是来自包含上下文，最后一个变量对象<strong>始终</strong>是全局上下文。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索从顶端开始，逐级往后，直至搜索到标识符，或者搜索到了全局作用域为止。</p><p>看个小例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        <span class="comment">//  这里能访问color,anotherColor,tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  这里能访问color, anotherColor,但是访问不了tempColor</span></span><br><span class="line">    <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><p>上述代码涉及三个上下文，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">|__color</span><br><span class="line">|__changeColor()</span><br><span class="line">  |__anotherColor</span><br><span class="line">  |__swapColors()</span><br><span class="line">    |__tempColor</span><br></pre></td></tr></table></figure><p>内部的上下文可以访问外部上下文的变量和函数，反之不行。</p><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>有两种情况可以增强作用域链，它们都会在作用域的前端添加一个变量对象：</p><ul><li><code>try/catch</code> 语句的<code>catch</code>  块：创建一个新的变量对象，包含要抛出的错误。</li><li><code>with</code> 语句：添加一个指定的对象。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;  <span class="comment">//  块级作用域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildUrl</span>();  <span class="comment">//  ReferenceError: url is not defined</span></span><br></pre></td></tr></table></figure><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是指哪些引用了另一个函数作用域中的变量的函数，通常是在嵌套函数中实现的。看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述代码中内部函数的输出语句，引用了外部函数的变量，在这个内部函数被返回并在其他地方调用后，仍然引用着该变量。因为内部函数的作用域链包含了外部函数和全局的变量对象。</p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>闭包能够使函数在其他地方调用时，也能够访问到其外部函数的变量。这使得其在特定场景下具有重要的应用。</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数柯里化是指将一个接收多个参数的函数拆分成多个只接受单个参数的函数。其优势是能够实现参数的复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w, h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">&#125;  <span class="comment">//  求面积，但是需要一直传入宽和高，如果宽固定而高变化，就不能实现复用</span></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//  柯里化之后，内部返回新的函数只接收高</span></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getTenWidthArea</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="实现私有变量"><a href="#实现私有变量" class="headerlink" title="实现私有变量"></a>实现私有变量</h3><p>使用闭包可以轻松实现私有变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  count += val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="keyword">const</span> counter2 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  2</span></span><br><span class="line">counter1.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述函数返回包含了特权方法的对象，能够访问函数内部的私有变量以及已有方法。<code>counter1</code> 和<code>counter2</code> 分别维护各自的私有变量，互不影响。</p><p>总的来说，闭包可以延长变量的生命周期。即使外部函数执行完毕返回结果了，其活动变量并不会销毁，因为内部函数的作用域链仍有它的引用。</p><h2 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h2><p>因为闭包会保留它们包含函数额作用域，所以比其他函数更占内存。过渡使用可能导致内存过渡占用。而且在处理速度和内存消耗方面对脚本具有负面影响。因此建议仅在十分必要时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line">bar = <span class="literal">null</span>;  <span class="comment">//  解除对函数的引用，这样就可以释放内存了</span></span><br></pre></td></tr></table></figure><p>Done！😊！</p>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中闭包相关的概念</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——队列</title>
    <link href="http://ianblog.top/posts/63bb1f4.html"/>
    <id>http://ianblog.top/posts/63bb1f4.html</id>
    <published>2023-04-19T03:21:01.000Z</published>
    <updated>2023-09-20T03:06:25.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>队列是一种<strong>先进先出</strong>的数据结构。</p></blockquote><h2 id="队列是什么？"><a href="#队列是什么？" class="headerlink" title="队列是什么？"></a>队列是什么？</h2><p>对列遵循<strong>先进先出（FIFO）</strong>，在队列尾部添加元素，在顶部移除元素。</p><p>队列在日常生活中是很常见的，比如买票排队。</p><h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><p>由于队列是从顶部移除元素，所以不仅需要获取队列尾部，还需要定义变量记录队列顶部位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;; <span class="comment">// 队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>; <span class="comment">// 追踪最后元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>; <span class="comment">// 追踪第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些方法了：最基础的就是添加与删除了</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>enqueue</code>(element)</td><td>添加元素</td></tr><tr><td><code>dequeue()</code></td><td>删除第一项元素并返回</td></tr><tr><td><code>front()</code></td><td>返回队列第一项元素</td></tr><tr><td><code>isEmpty()</code></td><td>检查队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回队列长度</td></tr><tr><td><code>clear()</code></td><td>清空队列</td></tr><tr><td><code>toString()</code></td><td>以字符串的方式打印队列</td></tr></tbody></table><h3 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h3><p>以<code>lastPos</code>作为键，将元素添加进队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lastPos</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h3><p>首先取得首个元素，然后将其删除，要注意的是，删除首个元素之后，它的下一个元素就成了首个元素了，所以需要将<code>firstPos</code>的值更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span>++; <span class="comment">// 自增，首个元素的索引后移</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-第一项元素"><a href="#3-第一项元素" class="headerlink" title="3. 第一项元素"></a>3. 第一项元素</h3><p><code>firstPos</code>用来追踪第一项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-队列是否为空"><a href="#4-队列是否为空" class="headerlink" title="4. 队列是否为空"></a>4. 队列是否为空</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span> === <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 或者为了复用方法</span></span><br><span class="line">  <span class="comment">// return this.size() === 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列长度"><a href="#5-队列长度" class="headerlink" title="5. 队列长度"></a>5. 队列长度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-清空队列"><a href="#6-清空队列" class="headerlink" title="6. 清空队列"></a>6. 清空队列</h3><p>重置队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-打印队列"><a href="#7-打印队列" class="headerlink" title="7. 打印队列"></a>7. 打印队列</h3><p>将队列中的元素以字符串的形式打印出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.firstPos]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">firstPos</span> + <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">lastPos</span>; i++) &#123;</span><br><span class="line">    str += <span class="string">`,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;ian&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;ian,jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;ian&#x27;</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>上面我们创建出了一个队列，实现了从队列尾部添加元素，顶部移除元素。如果我们还想要实现从队列尾部删除元素，从顶部添加元素呢？这就需要借助双端队列了。</p><p><strong>双端队列</strong>是一种允许我们同时从队列顶部和尾部添加和移除元素的特殊队列。有了这样的结构，双端队列既能实现<strong>先进先出</strong>又能实现<strong>后进先出</strong>，所以可以将其看作队列和栈相结合的一种数据结构。</p><h3 id="创建双端队列"><a href="#创建双端队列" class="headerlink" title="创建双端队列"></a>创建双端队列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">  constructor &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于双端队列非常类似于队列与栈的结合，所以其方法也是类似的，这里就不再累述了。唯一不同的就是，双端队列还需要实现从顶部添加元素的方法。</p><h4 id="顶部添加元素"><a href="#顶部添加元素" class="headerlink" title="顶部添加元素"></a>顶部添加元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addFront</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 若为空，则直接添加</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">enqueue</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">firstPos</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 若顶部有空位则添加至空位</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span>--;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>] = element;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若顶部无空位，则将元素整体往后推一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lastPos</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[i] = <span class="variable language_">this</span>.<span class="property">items</span>[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>] = element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用队列解决问题"><a href="#利用队列解决问题" class="headerlink" title="利用队列解决问题"></a>利用队列解决问题</h2><h3 id="1-击鼓传花"><a href="#1-击鼓传花" class="headerlink" title="1. 击鼓传花"></a>1. 击鼓传花</h3><p>问题描述：一群孩子围成一个圈，把花传递给傍边的人，一定时间后，花落在谁手上，谁就被淘汰，最终剩下的孩子为胜者。</p><p>问题思路：采用<strong>循环队列</strong>的方式，将所有孩子添加进队列，依次将顶部孩子移除再添加进尾部（传花之后，当前孩子就变成了最末尾的了）。每次循环淘汰一名孩子，最后剩下一名。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> element: Array 待添加的元素列表</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> num: Number 传花的次数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elements, num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> elimitates = []; <span class="comment">// 淘汰列表</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(element[i]); <span class="comment">// 循环添加元素</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 当剩下一个以上时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 出队再入队 -- 循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    elimitates.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 传完花之后，当前拿到花的淘汰</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    elimitates,</span><br><span class="line">    <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;ian&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;kate&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">hotPotato</span>(names, <span class="number">4</span>); <span class="comment">// &#x27;ian&#x27; is the winner</span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>首先添加元素：’ian’ — ‘jack’ — ‘kate’；</li><li>然后传花：<del>‘jack’</del> —‘kate’ — ‘ian’；</li><li>再次传花：<del>‘kate’</del> — ‘ian’；</li><li>剩下：’ian’</li></ol><h3 id="2-回文检查"><a href="#2-回文检查" class="headerlink" title="2. 回文检查"></a>2. 回文检查</h3><p>回文是正反都能读通的单词、词语或者字符串。最简单检验一个值是否是回文结构的方式就是将字符串翻转（<code>reverse</code>），然后再比较前后是否一致。</p><p>实现思路：在上面我们实现了双端队列，能够在两端移除元素，非常适合用于判断一个字符串是否为回文数。只需要循环移除两端元素并且判断是否相等即可。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 不是字符串则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> string = <span class="title function_">str</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 移除空格</span></span><br><span class="line">  <span class="keyword">let</span> firstChar; <span class="comment">// 首个字符</span></span><br><span class="line">  <span class="keyword">let</span> lastChar; <span class="comment">// 末尾字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    deque.<span class="title function_">enqueue</span>(string.<span class="title function_">charAt</span>(i)); <span class="comment">// 循环添加</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 有可能遇到字符数为奇数的情况，所以只需最后的size为0或者1就行</span></span><br><span class="line">    firstChar = deque.<span class="title function_">dequeue</span>(); <span class="comment">// 移除首个字符</span></span><br><span class="line">    lastChar = deque.<span class="title function_">pop</span>(); <span class="comment">// 移除末尾字符</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPalindrome</span>(<span class="string">&#x27;yakiooikay&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——队列</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——栈</title>
    <link href="http://ianblog.top/posts/93fd0851.html"/>
    <id>http://ianblog.top/posts/93fd0851.html</id>
    <published>2023-04-17T01:21:01.000Z</published>
    <updated>2023-09-20T02:01:42.338Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈是一种<strong>后进先出</strong>的数据结构，具有广泛的应用。</p></blockquote><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈遵循后进先出（LIFO）原则。新添加的元素保存在栈顶，待删除的元素也是从栈顶开始删除；在栈的另一端就叫栈底。</p><p>栈非常适合用于保存浏览器的历史记录，新产生的记录压入栈顶，显示新页面，等到点击回退按钮之后，就将当前栈顶的记录弹出，重新显示上一次的页面。</p><h2 id="创建一个栈"><a href="#创建一个栈" class="headerlink" title="创建一个栈"></a>创建一个栈</h2><p>栈需要满足保存一系列元素，并且轻松实现添加以及删除元素，这让我们很容易想到<strong>数组</strong>。因为数组本身具备操作元素的方法，例如<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code>等等。事实上，利用对象也是能够实现的，继续往下看 😀。</p><h3 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = []; <span class="comment">// 用于保存元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要思考：栈需要实现什么样的方法？</p><p>当然，最基本的添加与删除是毋庸置疑的。除此之外，还应当实现方法来方便获取栈顶元素，元素个数，以及重置栈。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>push(element)</code></td><td>添加一个或者几个元素到栈顶</td></tr><tr><td><code>pop()</code></td><td>移除并返回栈顶元素</td></tr><tr><td><code>peek()</code></td><td>返回栈顶的元素（并不移除）</td></tr><tr><td><code>isEmpty()</code></td><td>检查栈是否为空</td></tr><tr><td><code>clear()</code></td><td>清空栈</td></tr><tr><td><code>size()</code></td><td>返回栈中元素个数</td></tr><tr><td><code>toString()</code></td><td>以字符串形式打印出所有元素</td></tr></tbody></table><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>利用数组的<code>push</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>利用数组的<code>pop</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-查看栈顶元素"><a href="#3-查看栈顶元素" class="headerlink" title="3. 查看栈顶元素"></a>3. 查看栈顶元素</h4><p>相当于是获取数组中最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-检查栈是否为空"><a href="#4-检查栈是否为空" class="headerlink" title="4. 检查栈是否为空"></a>4. 检查栈是否为空</h4><p><code>length</code>属性反映了数组元素的个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈"><a href="#5-清空栈" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>这里简单粗暴，直接将空数组赋值给了<code>items</code>，也可以循环调用<code>pop</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数"><a href="#6-元素个数" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素"><a href="#7-打印元素" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>直接使用数组身上的<code>toString</code>方法（将元素以逗号分隔的字符串形式返回）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// true</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// 添加元素2</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// 添加元素5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">toString</span>()); <span class="comment">// &quot;2,5&quot;</span></span><br><span class="line">stack.<span class="title function_">pop</span>(); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>() &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>; <span class="comment">// 记录栈的大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的是，这里我们借助了<code>count</code>来记录栈的大小，因为对象不像数组拥有<code>length</code>属性。</p><h4 id="1-添加元素-1"><a href="#1-添加元素-1" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>直接使用<code>count</code>作为键名，<code>element</code>作为键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++; <span class="comment">// 自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素-1"><a href="#2-删除元素-1" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>首先需要检查栈是否为空，若为空，则返回 undefined。对象删除元素，需要手动修改 count 的值，并且删除之前先将其保存以便返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>--; <span class="comment">// 递减</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-检查栈是否为空"><a href="#3-检查栈是否为空" class="headerlink" title="3. 检查栈是否为空"></a>3. 检查栈是否为空</h4><p>直接判断<code>count</code>的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查看栈顶元素"><a href="#4-查看栈顶元素" class="headerlink" title="4. 查看栈顶元素"></a>4. 查看栈顶元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span> - <span class="number">1</span>]; <span class="comment">// 栈顶元素是最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈-1"><a href="#5-清空栈-1" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>将栈的状态重置为最初状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数-1"><a href="#6-元素个数-1" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><p>只需要简单返回count的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素-1"><a href="#7-打印元素-1" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>数组版本中，数组实例身上有<code>toString()</code>方法，该方法可以将元素转换成以逗号分隔的字符串形式。但是对象需要我们手动实现一个方法打印其所有元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 若为空，则返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>; <span class="comment">// 动态拼接字符串即可</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的使用"><a href="#栈的使用" class="headerlink" title="栈的使用"></a>栈的使用</h2><h3 id="1-十进制转换"><a href="#1-十进制转换" class="headerlink" title="1. 十进制转换"></a>1. 十进制转换</h3><p>十进制转换为其他的进制，相信大家都很熟悉：将十进制数除以要转换的进制数，对商取整，直到结果为0，然后将每次计算的余数拼接就得到了对应的进制数（要特别注意的是有的数需要转成字母）。</p><p>看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dgts = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>; <span class="comment">// 进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">decNumber, base</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = decNumber;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> rem = <span class="number">0</span>; <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>; <span class="comment">// 待拼接的字符串</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 边界情况，不能实现转换，返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number % base); <span class="comment">// 取余</span></span><br><span class="line">    stack.<span class="title function_">push</span>(rem); <span class="comment">// 添加余数</span></span><br><span class="line">    number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number / base); <span class="comment">// 更新number的值</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    str += dgts[stack.<span class="title function_">pop</span>()]; <span class="comment">// 拼接余数，从栈顶开始并且要做转换</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> str; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 1010</span></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">1021</span>, <span class="number">16</span>); <span class="comment">//3fd</span></span><br></pre></td></tr></table></figure><h3 id="2-平衡括号"><a href="#2-平衡括号" class="headerlink" title="2. 平衡括号"></a>2. 平衡括号</h3><p>每个左括号都必须要有对应的右括号，才算平衡，例如<code>((&#123;&#125;)&#123;&#125;([])())</code>。不平衡的如<code>(()</code>、<code>&#123;[)&#125;</code>等。基本的思路是，将左括号压入栈中，每次遇到右括号，就进行判断，看当前栈顶的括号是否与右括号对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> left = <span class="string">&#x27;([&#123;&#x27;</span>; <span class="comment">// 左括号</span></span><br><span class="line"><span class="keyword">const</span> right = <span class="string">&#x27;)]&#125;&#x27;</span>; <span class="comment">// 右括号</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parenthesesChecker</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> balanced = <span class="literal">true</span>; <span class="comment">// 是否平衡</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 循环变量</span></span><br><span class="line">  <span class="keyword">let</span> symbol; <span class="comment">// 字符</span></span><br><span class="line">  <span class="keyword">let</span> top; <span class="comment">// 栈顶字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; symbols.<span class="property">length</span> &amp;&amp; balanced) &#123;</span><br><span class="line">    symbol = symbols[i]; <span class="comment">// 对应索引的字符</span></span><br><span class="line">    <span class="keyword">if</span> (left.<span class="title function_">indexOf</span>(symbol) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(symbol); <span class="comment">// 压入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 遇到右括号但是栈为空</span></span><br><span class="line">      balanced = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      top = stack.<span class="title function_">pop</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">      <span class="keyword">if</span> (!(left.<span class="title function_">indexOf</span>(top) === right.<span class="title function_">indexOf</span>(symbol))) &#123; <span class="comment">// 左右括号比较</span></span><br><span class="line">        balanced = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balanced &amp;&amp; stack.<span class="title function_">isEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——栈</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://ianblog.top/posts/925e68ec.html"/>
    <id>http://ianblog.top/posts/925e68ec.html</id>
    <published>2023-04-15T12:11:06.000Z</published>
    <updated>2023-09-20T02:01:42.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ECMAScript 2015 </code>支持<code>class</code>关键字，正式引入了类的概念。但在此之前，通过原型链以及构造函数的方式也可以模拟类的特性。</p></blockquote><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型?"></a>什么是<strong>原型</strong>?</h3><p>在 JS 中，每个函数（箭头函数除外）都会创建出一个<code>prototype</code>属性，该属性作为一个指针，指向保存了实例应该共享的属性和方法的对象。并且该对象会自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实例属性共享"><a href="#实例属性共享" class="headerlink" title="实例属性共享"></a>实例属性共享</h3><p>通过给原型对象添加属性和方法，可以被对象实例共享（这也是为什么明明对象自身没有指定的属性，但却能够读取出值来的原因）。这样做的好处是，不用给每个实例单独定义属性和方法，一劳永逸。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;ian&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">p.<span class="title function_">sayName</span>(); <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><h3 id="构造函数、原型、实例之间的关系"><a href="#构造函数、原型、实例之间的关系" class="headerlink" title="构造函数、原型、实例之间的关系"></a>构造函数、原型、实例之间的关系</h3><p>关键在于理解这一点：<strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</strong>。</p><p>使用<code>new</code>关键字创建实例，实例内部的<code>[[Prototype]]</code>指针会指向原型对象。需要说明的是：原型对象本身是<code>Object</code>的实例（如果没有重新赋值的话），所以它也有原型。如果原型是另一个类型的实例，那么实例与原型之间通过像链一样的形式连接起来，构成了<strong>原型链</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在通过对象访问属性的时候，先是会搜索对象本身，如果没找到，则会顺着指针进入原型对象，若还是没找到，则继续沿着原型链寻找，直至找到或者原型对象变为<code>null</code>（类似于变量查询的方式）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承这个概念很好理解，比如现实生活中，某某某继承了他父亲留下的亿万资产、这个小孩继承了家族优秀的基因…继承描述的就是对象获取到了什么（属性和方法）。</p></blockquote><h3 id="ES5-之前的继承方式"><a href="#ES5-之前的继承方式" class="headerlink" title="ES5 之前的继承方式"></a>ES5 之前的继承方式</h3><p>在这一阶段的继承主要是通过原型链的方式实现的。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>主要思路就是：使一个构造函数的原型对象指向另一个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lee&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 重写子类原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayName</span>); <span class="comment">// &quot;lee&quot;</span></span><br></pre></td></tr></table></figure><p>优点：这种继承方式的好处在于，子类的实例能够继承父类实例以及原型上的属性和方法。</p><p>缺点：原型中如果出现引用类型，实例之间会出现属性共享的问题（修改属性会反映到所有的实例上）；子类实例化无法给父类型传递参数。</p><h4 id="2-盗用构造函数继承"><a href="#2-盗用构造函数继承" class="headerlink" title="2. 盗用构造函数继承"></a>2. 盗用构造函数继承</h4><p>主要思路是：在子构造函数中调用父构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;sing&quot;</span>, <span class="string">&quot;dance&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;lee&quot;</span>); <span class="comment">// 调用父构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">s1.<span class="property">hobby</span>.<span class="title function_">push</span>(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobby</span>); <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;, &quot;eat&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">hobby</span>); <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：通过<code>call</code>或者<code>apply</code>方法改变<code>this</code>值，可以实现传参；并且每个实例之间有单独的属性（不共享）。</p><p>缺点：子类型无法访问到父类型原型上的属性和方法；而且要实现方法的继承，必须在构造函数中定义方法，因此函数不能重用。</p><h4 id="3-组合式继承（伪经典继承）"><a href="#3-组合式继承（伪经典继承）" class="headerlink" title="3. 组合式继承（伪经典继承）"></a>3. 组合式继承（伪经典继承）</h4><p>主要思路：结合原型链继承和盗用构造函数继承，通过原型链继承原型上的属性和方法，盗用构造函数继承实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functon <span class="title class_">Son</span>(name, age) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 继承原型方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>)</span><br><span class="line">s.<span class="title function_">sayName</span>() <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><p>优点：弥补了原型链继承和盗用构造函数继承的不足。</p><p>缺点：需要调用两次父构造函数；并且实例属性会覆盖原型上同名属性。</p><h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>主要思路：封装一个<code>object</code>函数，其中临时创建构造函数，以传入对象作为其原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); <span class="comment">// 相当于给实例指定了原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;marry&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="title function_">object</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lucas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;marry&quot;, &quot;lucas&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：不需要单独创建构造函数。</p><p>缺点：实例之间引用值共享问题。</p><h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>主要思路：其实是类似于原型式继承的，在其基础上增强了对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">creatAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title function_">object</span>(original);</span><br><span class="line">  <span class="comment">// 增强对象</span></span><br><span class="line">  obj.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">creatAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>优点：同样不需要单独创建构造函数，只关注对象。</p><p>缺点：实例之间引用值共享问题；并且通过这种方式给实例添加方法是不能重用的。</p><h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h4><p>主要思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本（寄生式继承父类原型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Son, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">object</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constuctor</span> = <span class="title class_">Son</span>; <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>, <span class="title class_">Parent</span>); <span class="comment">// 继承原型属性</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>);</span><br><span class="line">s1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">s1.<span class="title function_">sayAge</span>(); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>优点：解决了组合式继承存在的效率问题（父构造函数调用两次）；可以说是引用类型继承的最佳模式。</p><h3 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a><code>ES6</code>中的继承</h3><p><code>ES6</code>引入的<code>class</code>关键字具有正式定义类的能力。事实上，类是<code>ECMAScript</code>中的语法糖结构，其背后的思想仍然是原型和构造函数。</p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>使用<code>extends</code>关键字可以完成继承，能继承任何拥有<code>[[Constructor]]</code>和原型的对象（包括类以及构造函数）。类和原型上的方法都会都带到派生类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">prompt</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">showClass</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;&#125; <span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">prompt</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">b.<span class="title function_">prompt</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Foo&quot;</span>); <span class="comment">// &quot;Foo&quot;</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Bar&quot;</span>); <span class="comment">// &quot;Bar&quot;</span></span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>派生类的方法可以通过<code>super</code>引用它们的原型，但仅限于类构造函数、实例方法和静态方法内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">contructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">identify</span>(); <span class="comment">// &quot;ok&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>super</code>不是必须要调用的。如果没有定义类构造函数，在实例化派生类时会自动调用<code>super()</code>，而且会传入传给派生类的参数。但是如果派生类显式定义了构造函数，那么必须调用<code>super()</code>或者返回一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用super</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 返回对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中常见的实现继承的方式</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
