<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ian的Blog小屋</title>
  
  <subtitle>好看的皮囊千篇一律，有趣的灵魂万里挑一</subtitle>
  <link href="http://ianblog.top/atom.xml" rel="self"/>
  
  <link href="http://ianblog.top/"/>
  <updated>2023-09-23T13:26:11.860Z</updated>
  <id>http://ianblog.top/</id>
  
  <author>
    <name>Ian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript——类型声明文件</title>
    <link href="http://ianblog.top/posts/d4bec260.html"/>
    <id>http://ianblog.top/posts/d4bec260.html</id>
    <published>2023-06-27T06:31:28.000Z</published>
    <updated>2023-09-23T13:26:11.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript中有一类特殊文件——类型声明文件。</p><p>关于TypeScript的内容也可以<a href="https://ianlee5645.github.io/learn-typescript">戳</a>⬅️</p></blockquote><h1 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h1><p>我们知道TS代码文件的类型是<code>.ts</code>文件，实际开发中会出现另一种类型：<code>.d.ts</code>文件。</p><p>这是因为：在开发的过程中，不可避免要使用到第三方的JS库。</p><p>我们在使用第三方库的时候，会发现它们几乎都有相应的TS类型。</p><p>这是由于类型声明文件，给已存在的JS库提供了类型信息。</p><p>因此，在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>类型声明文件就是用来提供类型信息的文件，只包含类型信息，不包含可执行代码。编译时不会生成相应的<code>js</code>文件。作用是给JS提供类型信息。</p><p>所以JS库要能够提供类型信息，需要使用<code>.d.ts</code>文件。</p><h2 id="内置类型声明文件"><a href="#内置类型声明文件" class="headerlink" title="内置类型声明文件"></a>内置类型声明文件</h2><p>TS为JS运行时可用的所有标准化内置API都提供了声明文件。</p><p>例如，使用数组的<code>forEach</code>方法的时候：</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/file01.png"></p><p>会显示出对应类型声明文件，上面是<code>lib.es5.d.ts</code>。</p><h2 id="第三方库类型声明文件"><a href="#第三方库类型声明文件" class="headerlink" title="第三方库类型声明文件"></a>第三方库类型声明文件</h2><ol><li>有的第三方库自带有类型声明文件，例如<code>vue</code>：</li></ol><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/file02.png"></p><p>这种情况下，正常导入该库，TS 就会自动加载库自己的类型声明文件，以提供该      库的类型声明。</p><ol start="2"><li><p>如果第三方库中没有，可以下载对应的TS类型声明包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev @types/* // *表示库的名称</span><br><span class="line">// 例如：</span><br><span class="line">npm i --save-dev @types/react</span><br></pre></td></tr></table></figure><blockquote><p>具体可以查看<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/"><code>DefinitelyTyped</code></a>.</p></blockquote></li></ol><h3 id="自定义类型声明文件"><a href="#自定义类型声明文件" class="headerlink" title="自定义类型声明文件"></a>自定义类型声明文件</h3><p>当类型需要多个文件共享，可以使用模块机制（<code>import/export</code>）。</p><p>当需要给存在的变量声明类型，可以使用<code>declare</code>关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的），可以省略 declare 关键字。</li><li>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明确指定此处用于类型声明。</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的类型声明文件。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——进阶</title>
    <link href="http://ianblog.top/posts/4574082c.html"/>
    <id>http://ianblog.top/posts/4574082c.html</id>
    <published>2023-06-24T09:21:48.000Z</published>
    <updated>2023-09-23T13:21:31.065Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript中有许多高级特性。</p><p>关于TypeScript的内容也可以<a href="https://ianlee5645.github.io/learn-typescript">戳</a>⬅️</p></blockquote><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><p>TS中的高级类型有很多，例如：class类，交叉类型，泛型，索引签名类型，映射类型。</p><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TS是面向对象的JS，支持面向对象的全部特性，比如类、接口等。</p><p>TS全面支持ES2015中引入的class关键字，并为其添加了类型注解和其他语法。</p><p>TS中的类包含以下模块（类的数据成员）：</p><ul><li>字段：字段是类里面声明的变量。字段表示对象的有关数据。</li><li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li><li>方法：  方法为对象要执行的操作。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123; </span><br><span class="line">    <span class="comment">// 字段 </span></span><br><span class="line">    <span class="attr">engine</span>: <span class="built_in">string</span>;</span><br><span class="line">    wheels = <span class="number">4</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数 </span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">engine: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">engine</span> = engine </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    <span class="title function_">disp</span>(): <span class="built_in">void</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发动机为 : &quot;</span> + <span class="variable language_">this</span>.<span class="property">engine</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Engine 1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/advanceType01.png"></p><p>说明：</p><ul><li>根据TS中类型推论，实例对象c的类型是Car。</li><li>TS中的class，不仅提供了class的语法功能，也作为一种类型存在。</li><li>方法的类型注解（参数和返回值）与函数用法相同。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>类实现继承有两种方式：</p><ol><li><p>extends（继承父类）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">miaow</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br></pre></td></tr></table></figure></li><li><p>implements（实现接口）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">  <span class="title function_">sing</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> <span class="keyword">implements</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">  <span class="title function_">sing</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;lalala&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口意味着类中要提供接口中指定的所有方法和属性。</p></li></ol><h3 id="类成员的访问控制修饰符"><a href="#类成员的访问控制修饰符" class="headerlink" title="类成员的访问控制修饰符"></a>类成员的访问控制修饰符</h3><p>TS中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。包括三类：</p><ul><li><p><strong>public</strong>:：表示公有的、公开的，公有成员可以被任何地方访问，默认可见性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>protected</strong>：表示受保护的，仅对其声明所在类和子类中（非实例对象）可见。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">miaow</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">move</span>()  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encapsulate</span> &#123; </span><br><span class="line">   <span class="attr">str1</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span> </span><br><span class="line">   <span class="keyword">private</span> <span class="attr">str2</span>: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Encapsulate</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str1</span>)     <span class="comment">// 可访问 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str2</span>)   <span class="comment">// 编译错误， str2 是私有的</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/advanceType02.png"></p></li></ul><p>额外的修饰符：**<code>readonly</code>**</p><p>**<code>readonly</code>**：表示只读，用来防止在构造函数之外对属性进行赋值，只能用来修饰属性。</p><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>功能类似于接口继承，用于组合多个类型为一个类型（常用于接口），用&amp;实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Contact</span> &#123;<span class="attr">phone</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Contact</span></span><br><span class="line">le <span class="attr">obj</span>: <span class="title class_">PersonDetail</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">phone</span>: <span class="string">&#x27;1818181818&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = &#123;<span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">phone</span>: <span class="built_in">string</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交叉类型（&amp;）与接口继承（extends）都可以实现对象类型的组合。不同的是对于同名属性的合并处理：</p><p>接口继承（extends）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现错误：</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/advanceType03.png"></p><p>交叉类型（&amp;）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B</span><br></pre></td></tr></table></figure><p>不出现错误：</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/advanceType04.png"></p><p>可以理解为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>如果对于一个函数，我们的目的是传入什么数据就返回什么数据，也就是说参数和返回值的类型要一致。这样的话，很容易想到any：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;<span class="keyword">return</span> value&#125;</span><br></pre></td></tr></table></figure><p>但是使用any的话，会丢失TS的类型保护。所以需要借助泛型。</p><p>泛型能够在保证类型安全的前提下，让函数，接口等可以与多种类型一起工作，从而实现复用，常用于函数，接口，类中。</p><p>格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;<span class="keyword">return</span> value&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在函数名称后面添加&lt;&gt;，然后在其中写入类型变量。</li><li>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值。</li><li>类型变量相当于一个类型容器，能够捕获用户提供的类型。</li><li>Type可以是任意合法的变量名称。</li></ul><p>调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = fn&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> str = fn&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">// 简化调用</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">fn</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在函数名称后面添加&lt;&gt;，然后在其中指定类型，之后类型变量Type就能捕获到类型。</li><li>如果省略&lt;&gt;，TS内部能根据实参推断出Type的类型。</li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>因为类型变量Type可以代表多个类型，这会导致意想不到的错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/advanceType05.png"></p><p>我们知道原始类型的数据是没有length属性的。</p><p>解决：给泛型添加约束，收缩类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.指定具体类型</span><br><span class="line">function fn&lt;Type&gt;(value: Type[]): Type[] &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br><span class="line">// 2.继承接口</span><br><span class="line">interface ILength &#123;length: number&#125;</span><br><span class="line">function fn&lt;Type extends ILength&gt;(value: Type): Type &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：泛型的类型变量可以有多个，并且类型变量之间可以约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="title function_">fn</span>(person, <span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><p><code>keyof</code>是个关键字，接收对象类型，生成键名的联合类型。本例为：<code>&quot;name&quot; | &quot;age&quot;</code>。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口可以配合泛型来使用，增强灵活性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdFunc</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">  <span class="attr">ids</span>: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">IdFunc</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">id</span>(<span class="params">value</span>) &#123;<span class="keyword">return</span> value&#125;,</span><br><span class="line">  <span class="title function_">ids</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类也能配合泛型来使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Type</span></span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: Type, y: Type</span>) =&gt;</span> <span class="title class_">Type</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myCal = <span class="keyword">new</span> <span class="title class_">Cal</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myCal.<span class="property">value</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="索引签名类型"><a href="#索引签名类型" class="headerlink" title="索引签名类型"></a>索引签名类型</h2><p>在定义接口的时候，我们可以很明确地指定对象的结构，但是有时候无法确定对象中会出现哪些属性（或者对象中可以出现任意属性），这时需要借助索引标签类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>上面的接口约束了对象的键只能是字符串类型，值是数值类型。</li><li>通过这种方式，只要满足要求，对象中 可以出现任意多的属性。</li><li><code>key</code>只是占位符，可以是任意合法的变量名称。</li></ul><h2 id="索引查询类型"><a href="#索引查询类型" class="headerlink" title="索引查询类型"></a>索引查询类型</h2><p>可以查询属性的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">string</span>, <span class="attr">c</span>: <span class="built_in">boolean</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span>]  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>]  <span class="comment">// number | string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[keyof <span class="title class_">Props</span>]  <span class="comment">// number | string | boolean</span></span><br></pre></td></tr></table></figure><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>基于旧类型创建出新类型（对象类型），减少重复：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>, <span class="attr">z</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="comment">// 映射类型写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;[k <span class="keyword">in</span> <span class="title class_">PropKeys</span>]: <span class="built_in">number</span>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>k in PropKeys</code>表示 <code>k </code>可以是 <code>PropKeys</code> 联合类型中的任意一个。</li><li><strong>映射类型只能在类型别名中使用，不能在接口中使用</strong></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的高级类型。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——基础</title>
    <link href="http://ianblog.top/posts/eb05c984.html"/>
    <id>http://ianblog.top/posts/eb05c984.html</id>
    <published>2023-06-20T13:18:28.000Z</published>
    <updated>2023-09-23T13:15:39.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript最大的特点就是给JavaScript加上了类型。</p><p>关于TypeScript的内容还可以访问：<a href="https://ianlee5645.github.io/learn-typescript">这里</a></p></blockquote><h1 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h1><p>TS中添加了类型注释，如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>其中的<code>: number</code>就是类型注释</p><p>作用：给变量添加类型约束。上述代码就是给<strong>age</strong>变量添加了<strong>number</strong>数值类型的约束。如果之后进行了下面的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="string">&#x27;18&#x27;</span></span><br></pre></td></tr></table></figure><p>代码编辑器就会报错：</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/baseType01.png"></p><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>TS中的类型有一部分是JS当中就存在的，有一部分是新增的。</p><ol><li>原本就有<ul><li>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol</li><li>对象类型：object</li></ul></li><li>新增：联合类型、自定义类型、接口、元组、字面量、枚举、void、any等</li></ol><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>双精度的64位浮点数，可以表示多种进制的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">binary</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octal</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;    <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dec</span>: <span class="built_in">number</span> = <span class="number">6</span>;    <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hex</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;    <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>同样支持单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>、反引号<code>`` </code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&#x27;man&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">words</span>: <span class="built_in">string</span> = <span class="string">`hello`</span>;</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><p>null表示空对象的引用，是一个只有一个值的特殊类型。</p><p>undefined是用于初始化一个未设置值的变量。</p><p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 编译错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><h2 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">symbol</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>使用数组类型可以限制数组中元素的类型。具体有两种基本的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素类型后面加上[]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 使用数组泛型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strings</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素既有数值又有字符</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>];</span><br></pre></td></tr></table></figure><p>上述写法更推荐使用**number[]**。</p><p>其中<code>|</code>在TS中叫做<strong>联合类型</strong>，是指由两个或多个其他类型组成的类型，表似可以是其中的任意一种。（后面会讲）</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数类型实际上指的是：函数参数和返回值的类型。有两种指定方式：</p><ol><li><p>分别指定参数、返回值的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时指定参数、返回值的类型（只适用于函数表达式+箭头函数的形式）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>函数参数的传递：JS中如果传递的实参<strong>少于</strong>或<strong>多于</strong>形参时，是不会报错的；但是TS会显示错误。</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/baseType02.png"></p><p>TS中可选参数：在可传可不传的参数名称后面添加?</p><p>这样就能解决上述问题了：</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/baseType03.png"></p><p>不过要注意的是：可选参数只能出现在参数列表的最后，也就是说可选参数的后面不能出现必选参数。</p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>TS中的对象类型是在描述对象的结构（有什么类型属性和方法）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="title function_">speak</span>(): <span class="built_in">void</span>&#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果方法带有参数的话，类似函数参数，写成：<code>speak(words: string): void</code>即可。</li><li>在一行指定对象类型时，各个属性之间用<code>,</code>或<code>;</code>分隔。</li><li>如果通过换行指定对象类型时，可以省略各个属性之间的分隔符。</li><li>同样，如果某个属性也是可选的，使用?即可。</li></ul><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）可以通过管道<code>|</code>将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p><p>格式：<code>Type1 | Type2 | Type3</code></p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">val</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">12</span></span><br><span class="line">val = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">disp</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>也称类型别名，为任意类型起别名。</p><p>当同一类型（复杂）被多次使用时，可以通过类型别名，<strong>简化</strong>该类型的使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CustomArray</span> = (<span class="built_in">number</span> | <span class="built_in">string</span>)[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">CustomArray</span> = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>自定义类型使用type关键字创建。</li><li>类型别名可以是任意合法的变量名。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现。</p><p>当一个对象类型被多次使用，最好使用接口来描述，以达到复用的目的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">speak</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>接口使用interface创建。</li><li>接口名可以是任意合法的变量名。</li><li>接口不能编译成对应的JS代码，他只是TS的一部分。</li><li>接口与类型别名的区别：<ul><li>接口只能为对象指定类型。</li><li>类型别名可以为任意类型指定别名。</li></ul></li></ul><p>当两个接口之间有共同的属性或方法，可以使用<strong>继承</strong>实现复用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;<span class="attr">weight</span>: <span class="built_in">string</span>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>使用extends关键字实现了Cat继承Animal。</li><li>继承之后，Cat也拥有了Animal的属性和方法。</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组是另一种类型的数组，它确切地知道包含多少个元素，以及特定索引对应的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39</span>, <span class="number">116</span>]</span><br></pre></td></tr></table></figure><p>应用场景：利用经纬度存储位置信息。</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>用于指定某个变量为某个值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="number">18</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure><p>对比：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure><p>结果：</p><ol><li>变量str1的类型为：string</li><li>常量str2的类型为：’Hello TS’</li></ol><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举定义了一组命名常量，描述一个值，该值是命名常量中的一个。</p><p>枚举的功能类似字面量类型+联合类型，表示一组可选值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;<span class="title class_">Sunday</span>, <span class="title class_">Monday</span>, <span class="title class_">Tuesday</span>, <span class="title class_">Wednesday</span>, <span class="title class_">Thursday</span>, <span class="title class_">Friday</span>, <span class="title class_">Saturday</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Day</span>.<span class="property">Sunday</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>枚举使用enum关键字创建。</p></li><li><p>约定枚举名称和值以大写字母开头，值用<code>,</code>分隔。</p></li><li><p>访问枚举成员，类似JS对象中的点语法。</p></li><li><p>枚举的值默认是从0开始自增的数值，这时称为数值枚举。</p></li><li><p>枚举的值还可以是字符串，每个成员都必须有初始值，这时称为字符串枚举。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类型会编译为JS代码，因为枚举不仅作为类型，还提供值。可以使用常量枚举，避免编译时创建该对象。<code>const enum ...</code></p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/baseType04.png"></p></li></ul><p>一般情况下，推荐使用字面量类型+联合类型的方式，因为更直观、简洁、高效。</p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>用于标识返回值的类型，标识方法没有返回值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>声明为any的变量可以赋予任意类型的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">&#x27;I an who I am&#x27;</span>;</span><br><span class="line">x = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>不推荐使用any，因为相当于不使用TS的类型特性。</li><li>上面代码显示声明了any类型，隐式声明的情况：<ul><li>声明变量不提供类型也不提供默认值</li><li>函数参数不声明类型</li></ul></li></ul><h2 id="类型的判断"><a href="#类型的判断" class="headerlink" title="类型的判断"></a>类型的判断</h2><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>TS中带有类型推论机制，可以在没有明确给出类型的情况下推断出类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;<span class="keyword">return</span> a + b&#125;</span><br></pre></td></tr></table></figure><p>这两种情况下，类型注解可以不写。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><ol><li><pre><code class="typescript">let someValue: number | string = &quot;this is a string&quot;let strLength: number = (someValue as string).length;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```typescript</span><br><span class="line">   let someValue: number | string = &quot;this is a string&quot;</span><br><span class="line">   let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>应用场景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://...&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linkDOM = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;link&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLAnchorElement</span></span><br></pre></td></tr></table></figure><p>说明：<br><code>getElementById</code> 方法返回值的类型是 <code>HTMLElement</code>，该类型只包含所有标签公共的属性或方法，不包含<code>a</code> 标签特有的 <code>href</code> 等属性。如果后续访问<code>href</code>属性，就会报错，通过类型断言使<code>linkDOM</code>的类型更具体。</p>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的类型注释和基础类型。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——介绍</title>
    <link href="http://ianblog.top/posts/92138a47.html"/>
    <id>http://ianblog.top/posts/92138a47.html</id>
    <published>2023-06-17T05:21:23.000Z</published>
    <updated>2023-09-23T13:06:02.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript为JavaScript带来了类型的概念。</p><p>关于TypeScript的内容，你可以访问<a href="https://ianlee5645.github.io/learn-typescript">戳我</a>。</p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript?"></a>什么是TypeScript?</h2><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/typescript-logo.jpg"></p><p>TypeScript（简称：TS）是JavaScript的超集，支持ES6语法。</p><p>TypeScript &#x3D; Type + JavaScript（引入了类型的概念）</p><p>TypeScript是微软开发的开源编程语言，能够编译成JavaScript。</p><p>下面是一个最基本的实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age, hello)</span><br></pre></td></tr></table></figure><h2 id="新增语言特性"><a href="#新增语言特性" class="headerlink" title="新增语言特性"></a>新增语言特性</h2><p>TypeScript相较于JavaScript新增了一些新的语言扩展，包括：</p><ul><li>类型</li><li>接口</li><li>枚举</li><li>元组</li><li>Mixin</li><li>…</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>TypeScript属于静态类型的编程语言，编译期做类型检查；而JavaScript属于动态类型的编程语言，执行期做类型检查。</p><p>TypeScript能够更早发现代码中存在的错误，节约修复代码的时间，提高效率。</p><p>完善的代码提示，提升开发体验。</p><p>兼容JavaScript，上手简单易用。</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/ts-js.png"></p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>安装命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><p>typescript包：用来编译TS代码的包，提供了tsc命令。</p><p><img src="https://gitee.com/ianlee5645/hexo-files/raw/master/ts-to-js.png"></p><p>检查是否安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure><p>使用：</p><p>创建一个hello.ts文件，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>此时在同级目录下会生成一个同名的JS文件。</p><p>执行JS代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure><p>扩展：</p><p>tsc能够同时编译多个ts文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure><p>tsc常用的编译参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–module</td><td>载入扩展模块</td></tr><tr><td>–target</td><td>设置ECMA版本</td></tr><tr><td>–removeComments</td><td>删除文件的注释</td></tr><tr><td>–out</td><td>编译多个文件并合并到一个输出的文件</td></tr><tr><td>–watch</td><td>在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译</td></tr></tbody></table><h2 id="简化步骤"><a href="#简化步骤" class="headerlink" title="简化步骤"></a>简化步骤</h2><p>可以使用ts-node包简化步骤，这样就不需要每次先编译然后再执行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br><span class="line">ts-node hello.ts</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的path模块。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——队列</title>
    <link href="http://ianblog.top/posts/63bb1f4.html"/>
    <id>http://ianblog.top/posts/63bb1f4.html</id>
    <published>2023-06-05T03:21:01.000Z</published>
    <updated>2023-09-22T13:09:24.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>队列是一种<strong>先进先出</strong>的数据结构。</p></blockquote><h2 id="队列是什么？"><a href="#队列是什么？" class="headerlink" title="队列是什么？"></a>队列是什么？</h2><p>对列遵循<strong>先进先出（FIFO）</strong>，在队列尾部添加元素，在顶部移除元素。</p><p>队列在日常生活中是很常见的，比如买票排队。</p><h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><p>由于队列是从顶部移除元素，所以不仅需要获取队列尾部，还需要定义变量记录队列顶部位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;; <span class="comment">// 队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>; <span class="comment">// 追踪最后元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>; <span class="comment">// 追踪第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些方法了：最基础的就是添加与删除了</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>enqueue</code>(element)</td><td>添加元素</td></tr><tr><td><code>dequeue()</code></td><td>删除第一项元素并返回</td></tr><tr><td><code>front()</code></td><td>返回队列第一项元素</td></tr><tr><td><code>isEmpty()</code></td><td>检查队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回队列长度</td></tr><tr><td><code>clear()</code></td><td>清空队列</td></tr><tr><td><code>toString()</code></td><td>以字符串的方式打印队列</td></tr></tbody></table><h3 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h3><p>以<code>lastPos</code>作为键，将元素添加进队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lastPos</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h3><p>首先取得首个元素，然后将其删除，要注意的是，删除首个元素之后，它的下一个元素就成了首个元素了，所以需要将<code>firstPos</code>的值更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span>++; <span class="comment">// 自增，首个元素的索引后移</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-第一项元素"><a href="#3-第一项元素" class="headerlink" title="3. 第一项元素"></a>3. 第一项元素</h3><p><code>firstPos</code>用来追踪第一项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-队列是否为空"><a href="#4-队列是否为空" class="headerlink" title="4. 队列是否为空"></a>4. 队列是否为空</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span> === <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 或者为了复用方法</span></span><br><span class="line">  <span class="comment">// return this.size() === 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列长度"><a href="#5-队列长度" class="headerlink" title="5. 队列长度"></a>5. 队列长度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-清空队列"><a href="#6-清空队列" class="headerlink" title="6. 清空队列"></a>6. 清空队列</h3><p>重置队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-打印队列"><a href="#7-打印队列" class="headerlink" title="7. 打印队列"></a>7. 打印队列</h3><p>将队列中的元素以字符串的形式打印出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.firstPos]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">firstPos</span> + <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">lastPos</span>; i++) &#123;</span><br><span class="line">    str += <span class="string">`,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;ian&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;ian,jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;ian&#x27;</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>上面我们创建出了一个队列，实现了从队列尾部添加元素，顶部移除元素。如果我们还想要实现从队列尾部删除元素，从顶部添加元素呢？这就需要借助双端队列了。</p><p><strong>双端队列</strong>是一种允许我们同时从队列顶部和尾部添加和移除元素的特殊队列。有了这样的结构，双端队列既能实现<strong>先进先出</strong>又能实现<strong>后进先出</strong>，所以可以将其看作队列和栈相结合的一种数据结构。</p><h3 id="创建双端队列"><a href="#创建双端队列" class="headerlink" title="创建双端队列"></a>创建双端队列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">  constructor &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于双端队列非常类似于队列与栈的结合，所以其方法也是类似的，这里就不再累述了。唯一不同的就是，双端队列还需要实现从顶部添加元素的方法。</p><h4 id="顶部添加元素"><a href="#顶部添加元素" class="headerlink" title="顶部添加元素"></a>顶部添加元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addFront</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 若为空，则直接添加</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">enqueue</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">firstPos</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 若顶部有空位则添加至空位</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span>--;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>] = element;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若顶部无空位，则将元素整体往后推一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lastPos</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[i] = <span class="variable language_">this</span>.<span class="property">items</span>[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>] = element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用队列解决问题"><a href="#利用队列解决问题" class="headerlink" title="利用队列解决问题"></a>利用队列解决问题</h2><h3 id="1-击鼓传花"><a href="#1-击鼓传花" class="headerlink" title="1. 击鼓传花"></a>1. 击鼓传花</h3><p>问题描述：一群孩子围成一个圈，把花传递给傍边的人，一定时间后，花落在谁手上，谁就被淘汰，最终剩下的孩子为胜者。</p><p>问题思路：采用<strong>循环队列</strong>的方式，将所有孩子添加进队列，依次将顶部孩子移除再添加进尾部（传花之后，当前孩子就变成了最末尾的了）。每次循环淘汰一名孩子，最后剩下一名。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> element: Array 待添加的元素列表</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> num: Number 传花的次数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elements, num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> elimitates = []; <span class="comment">// 淘汰列表</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(element[i]); <span class="comment">// 循环添加元素</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 当剩下一个以上时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 出队再入队 -- 循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    elimitates.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 传完花之后，当前拿到花的淘汰</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    elimitates,</span><br><span class="line">    <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;ian&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;kate&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">hotPotato</span>(names, <span class="number">4</span>); <span class="comment">// &#x27;ian&#x27; is the winner</span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>首先添加元素：’ian’ — ‘jack’ — ‘kate’；</li><li>然后传花：<del>‘jack’</del> —‘kate’ — ‘ian’；</li><li>再次传花：<del>‘kate’</del> — ‘ian’；</li><li>剩下：’ian’</li></ol><h3 id="2-回文检查"><a href="#2-回文检查" class="headerlink" title="2. 回文检查"></a>2. 回文检查</h3><p>回文是正反都能读通的单词、词语或者字符串。最简单检验一个值是否是回文结构的方式就是将字符串翻转（<code>reverse</code>），然后再比较前后是否一致。</p><p>实现思路：在上面我们实现了双端队列，能够在两端移除元素，非常适合用于判断一个字符串是否为回文数。只需要循环移除两端元素并且判断是否相等即可。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 不是字符串则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> string = <span class="title function_">str</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 移除空格</span></span><br><span class="line">  <span class="keyword">let</span> firstChar; <span class="comment">// 首个字符</span></span><br><span class="line">  <span class="keyword">let</span> lastChar; <span class="comment">// 末尾字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    deque.<span class="title function_">enqueue</span>(string.<span class="title function_">charAt</span>(i)); <span class="comment">// 循环添加</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 有可能遇到字符数为奇数的情况，所以只需最后的size为0或者1就行</span></span><br><span class="line">    firstChar = deque.<span class="title function_">dequeue</span>(); <span class="comment">// 移除首个字符</span></span><br><span class="line">    lastChar = deque.<span class="title function_">pop</span>(); <span class="comment">// 移除末尾字符</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPalindrome</span>(<span class="string">&#x27;yakiooikay&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——队列</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——栈</title>
    <link href="http://ianblog.top/posts/93fd0851.html"/>
    <id>http://ianblog.top/posts/93fd0851.html</id>
    <published>2023-06-02T01:21:01.000Z</published>
    <updated>2023-09-22T13:09:07.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈是一种<strong>后进先出</strong>的数据结构，具有广泛的应用。</p></blockquote><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈遵循后进先出（LIFO）原则。新添加的元素保存在栈顶，待删除的元素也是从栈顶开始删除；在栈的另一端就叫栈底。</p><p>栈非常适合用于保存浏览器的历史记录，新产生的记录压入栈顶，显示新页面，等到点击回退按钮之后，就将当前栈顶的记录弹出，重新显示上一次的页面。</p><h2 id="创建一个栈"><a href="#创建一个栈" class="headerlink" title="创建一个栈"></a>创建一个栈</h2><p>栈需要满足保存一系列元素，并且轻松实现添加以及删除元素，这让我们很容易想到<strong>数组</strong>。因为数组本身具备操作元素的方法，例如<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code>等等。事实上，利用对象也是能够实现的，继续往下看 😀。</p><h3 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = []; <span class="comment">// 用于保存元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要思考：栈需要实现什么样的方法？</p><p>当然，最基本的添加与删除是毋庸置疑的。除此之外，还应当实现方法来方便获取栈顶元素，元素个数，以及重置栈。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>push(element)</code></td><td>添加一个或者几个元素到栈顶</td></tr><tr><td><code>pop()</code></td><td>移除并返回栈顶元素</td></tr><tr><td><code>peek()</code></td><td>返回栈顶的元素（并不移除）</td></tr><tr><td><code>isEmpty()</code></td><td>检查栈是否为空</td></tr><tr><td><code>clear()</code></td><td>清空栈</td></tr><tr><td><code>size()</code></td><td>返回栈中元素个数</td></tr><tr><td><code>toString()</code></td><td>以字符串形式打印出所有元素</td></tr></tbody></table><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>利用数组的<code>push</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>利用数组的<code>pop</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-查看栈顶元素"><a href="#3-查看栈顶元素" class="headerlink" title="3. 查看栈顶元素"></a>3. 查看栈顶元素</h4><p>相当于是获取数组中最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-检查栈是否为空"><a href="#4-检查栈是否为空" class="headerlink" title="4. 检查栈是否为空"></a>4. 检查栈是否为空</h4><p><code>length</code>属性反映了数组元素的个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈"><a href="#5-清空栈" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>这里简单粗暴，直接将空数组赋值给了<code>items</code>，也可以循环调用<code>pop</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数"><a href="#6-元素个数" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素"><a href="#7-打印元素" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>直接使用数组身上的<code>toString</code>方法（将元素以逗号分隔的字符串形式返回）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// true</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// 添加元素2</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// 添加元素5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">toString</span>()); <span class="comment">// &quot;2,5&quot;</span></span><br><span class="line">stack.<span class="title function_">pop</span>(); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>() &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>; <span class="comment">// 记录栈的大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的是，这里我们借助了<code>count</code>来记录栈的大小，因为对象不像数组拥有<code>length</code>属性。</p><h4 id="1-添加元素-1"><a href="#1-添加元素-1" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>直接使用<code>count</code>作为键名，<code>element</code>作为键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++; <span class="comment">// 自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素-1"><a href="#2-删除元素-1" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>首先需要检查栈是否为空，若为空，则返回 undefined。对象删除元素，需要手动修改 count 的值，并且删除之前先将其保存以便返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>--; <span class="comment">// 递减</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-检查栈是否为空"><a href="#3-检查栈是否为空" class="headerlink" title="3. 检查栈是否为空"></a>3. 检查栈是否为空</h4><p>直接判断<code>count</code>的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查看栈顶元素"><a href="#4-查看栈顶元素" class="headerlink" title="4. 查看栈顶元素"></a>4. 查看栈顶元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span> - <span class="number">1</span>]; <span class="comment">// 栈顶元素是最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈-1"><a href="#5-清空栈-1" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>将栈的状态重置为最初状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数-1"><a href="#6-元素个数-1" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><p>只需要简单返回count的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素-1"><a href="#7-打印元素-1" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>数组版本中，数组实例身上有<code>toString()</code>方法，该方法可以将元素转换成以逗号分隔的字符串形式。但是对象需要我们手动实现一个方法打印其所有元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 若为空，则返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>; <span class="comment">// 动态拼接字符串即可</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的使用"><a href="#栈的使用" class="headerlink" title="栈的使用"></a>栈的使用</h2><h3 id="1-十进制转换"><a href="#1-十进制转换" class="headerlink" title="1. 十进制转换"></a>1. 十进制转换</h3><p>十进制转换为其他的进制，相信大家都很熟悉：将十进制数除以要转换的进制数，对商取整，直到结果为0，然后将每次计算的余数拼接就得到了对应的进制数（要特别注意的是有的数需要转成字母）。</p><p>看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dgts = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>; <span class="comment">// 进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">decNumber, base</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = decNumber;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> rem = <span class="number">0</span>; <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>; <span class="comment">// 待拼接的字符串</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 边界情况，不能实现转换，返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number % base); <span class="comment">// 取余</span></span><br><span class="line">    stack.<span class="title function_">push</span>(rem); <span class="comment">// 添加余数</span></span><br><span class="line">    number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number / base); <span class="comment">// 更新number的值</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    str += dgts[stack.<span class="title function_">pop</span>()]; <span class="comment">// 拼接余数，从栈顶开始并且要做转换</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> str; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 1010</span></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">1021</span>, <span class="number">16</span>); <span class="comment">//3fd</span></span><br></pre></td></tr></table></figure><h3 id="2-平衡括号"><a href="#2-平衡括号" class="headerlink" title="2. 平衡括号"></a>2. 平衡括号</h3><p>每个左括号都必须要有对应的右括号，才算平衡，例如<code>((&#123;&#125;)&#123;&#125;([])())</code>。不平衡的如<code>(()</code>、<code>&#123;[)&#125;</code>等。基本的思路是，将左括号压入栈中，每次遇到右括号，就进行判断，看当前栈顶的括号是否与右括号对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> left = <span class="string">&#x27;([&#123;&#x27;</span>; <span class="comment">// 左括号</span></span><br><span class="line"><span class="keyword">const</span> right = <span class="string">&#x27;)]&#125;&#x27;</span>; <span class="comment">// 右括号</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parenthesesChecker</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> balanced = <span class="literal">true</span>; <span class="comment">// 是否平衡</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 循环变量</span></span><br><span class="line">  <span class="keyword">let</span> symbol; <span class="comment">// 字符</span></span><br><span class="line">  <span class="keyword">let</span> top; <span class="comment">// 栈顶字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; symbols.<span class="property">length</span> &amp;&amp; balanced) &#123;</span><br><span class="line">    symbol = symbols[i]; <span class="comment">// 对应索引的字符</span></span><br><span class="line">    <span class="keyword">if</span> (left.<span class="title function_">indexOf</span>(symbol) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(symbol); <span class="comment">// 压入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 遇到右括号但是栈为空</span></span><br><span class="line">      balanced = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      top = stack.<span class="title function_">pop</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">      <span class="keyword">if</span> (!(left.<span class="title function_">indexOf</span>(top) === right.<span class="title function_">indexOf</span>(symbol))) &#123; <span class="comment">// 左右括号比较</span></span><br><span class="line">        balanced = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balanced &amp;&amp; stack.<span class="title function_">isEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——栈</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章带你学会SVG</title>
    <link href="http://ianblog.top/posts/5b54a0db.html"/>
    <id>http://ianblog.top/posts/5b54a0db.html</id>
    <published>2023-05-17T12:36:20.000Z</published>
    <updated>2023-09-23T13:31:02.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>SVG</code>是Web应用中常用的表示图片的方式。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>是一种基于XML语法的图像格式，全称是可缩放适量图。</p><p>特点是不管放大多少倍都不会<strong>失真</strong>。</p><p>SVG文件可以直接插入网页，成为DOM的一部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SVG代码也可以写在一个独立文件中，使用<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;iframe&gt;</code>等标签插入网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;circle.svg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">&quot;object&quot;</span> <span class="attr">data</span>=<span class="string">&quot;circle.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">id</span>=<span class="string">&quot;embed&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS也能使用SVG文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">icon.svg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVG还能转为BASE64编码，然后作为Data URI写入网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/svg+xml;base64,[data]&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标签"><a href="#标签" class="headerlink" title="&lt;svg&gt;标签"></a><code>&lt;svg&gt;</code>标签</h2><p>SVG代码放在顶层标签<code>&lt;svg&gt;</code>之中</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述例子中：<code>width</code>、<code>height</code>指定SVG图像在HTML元素中所占据的宽度和高度。可使用相对或者绝对单位。不指定的话，则是300px × 150px。如果只想展示SVG图像的一部分，则可以指定<code>viewBox</code>属性。该属性分别表示左上角的横坐标和纵坐标、视口的宽度和高度。视口必须适配所在的空间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;circle&gt;标签"></a><code>&lt;circle&gt;</code>标签</h2><p><code>&lt;circle&gt;</code>标签代表圆形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;30&quot;</span>  <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;90&quot;</span>  <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fancy&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码指定了三个圆。<code>cx</code>、<code>cy</code>、<code>r</code>属性分别表示横坐标、纵坐标和半径，单位为像素。相对于<code>&lt;svg&gt;</code>画布的左上角原点。<code>class</code>属性用来指定对应的CSS类。</p><p>SVG的CSS属性与网页元素有所不同：</p><ul><li>fill：填充色</li><li>stroke：描边色</li><li>stroke-width：边框宽度</li></ul><h2 id="标签-2"><a href="#标签-2" class="headerlink" title="&lt;line&gt;标签"></a><code>&lt;line&gt;</code>标签</h2><p><code>&lt;line&gt;</code>标签用来绘制直线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke:rgb(0,0,0);stroke-width:5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x1</code>、<code>y1</code>、<code>x2</code>、<code>y2</code>属性分别表示线段的起始和终止坐标；<code>style</code>属性表示线段的样式。</p><h2 id="标签-3"><a href="#标签-3" class="headerlink" title="&lt;polyline&gt;标签"></a><code>&lt;polyline&gt;</code>标签</h2><p><code>&lt;polyline&gt;</code>标签用于绘制一根折线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;60 110 65 120 70 115 75 130 80 125 85 140 90 135 95 150 100 145&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;transparent&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>points</code>属性指定每个端点的坐标。</p><h2 id="标签-4"><a href="#标签-4" class="headerlink" title="&lt;rect&gt;标签&gt;"></a><code>&lt;rect&gt;</code>标签&gt;</h2><p><code>&lt;rect&gt;</code>标签用于绘制矩形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke: #70d5dd; fill: #dd524b&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x</code>、<code>y</code>属性分别表示左上角端点的横坐标和纵坐标；<code>width</code>、<code>height</code>属性指定了矩形的宽度和高度。</p><h2 id="标签-5"><a href="#标签-5" class="headerlink" title="&lt;ellipse&gt;标签"></a><code>&lt;ellipse&gt;</code>标签</h2><p><code>&lt;ellipse&gt;</code>标签用于绘制椭圆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;40&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;20&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;silver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>cx</code>、<code>cy</code>属性，指定了椭圆中心的横坐标和纵坐标；<code>rx</code>、<code>ry</code>属性指定了椭圆横向轴和纵向轴的半径。</p><h2 id="标签-6"><a href="#标签-6" class="headerlink" title="&lt;polygon&gt;标签"></a><code>&lt;polygon&gt;</code>标签</h2><p><code>&lt;polygon&gt;</code>标签用于绘制多边形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">points</span>=<span class="string">&quot;0,0 100,0 100,100 0,100 0,0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>points</code>属性指定每个端点的坐标。</p><h2 id="标签-7"><a href="#标签-7" class="headerlink" title="&lt;path&gt;标签"></a><code>&lt;path&gt;</code>标签</h2><p><code>&lt;path&gt;</code>标签用于绘制路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  M 18,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 61,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 32,68</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 3,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 18,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  Z</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>d</code>属性表示绘制顺序，值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M：移动到 moveto</span><br><span class="line">L；画直线到 lineto</span><br><span class="line">Z：闭合路径 </span><br></pre></td></tr></table></figure><h2 id="标签-8"><a href="#标签-8" class="headerlink" title="&lt;text&gt;标签"></a><code>&lt;text&gt;</code>标签</h2><p><code>&lt;text&gt;</code>标签用于绘制文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;25&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x</code>、<code>y</code>属性表示文本区块基线起点的横坐标和纵坐标。样式可以用<code>class</code>、<code>style</code>属性指定。</p><h2 id="标签-9"><a href="#标签-9" class="headerlink" title="&lt;use&gt;标签"></a><code>&lt;use&gt;</code>标签</h2><p><code>&lt;use&gt;</code>标签用于复制一个形状</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 30 10&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;5&quot;</span> <span class="attr">r</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>href</code>属性指定所要复制的节点，<code>x</code>、<code>y</code>属性是左上角的坐标。还可以指定<code>width</code>、<code>height</code>属性。</p><h2 id="标签-10"><a href="#标签-10" class="headerlink" title="&lt;g&gt;标签"></a><code>&lt;g&gt;</code>标签</h2><p><code>&lt;g&gt;</code>标签用于将多个形状组成一个组（group），方便复用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>id</code>指定了组的ID</p><h2 id="标签-11"><a href="#标签-11" class="headerlink" title="&lt;defs&gt;标签"></a><code>&lt;defs&gt;</code>标签</h2><p><code>&lt;defs&gt;</code>标签用于自定义形状，它的内部代码不会显示，仅供引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-12"><a href="#标签-12" class="headerlink" title="&lt;pattern&gt;标签"></a><code>&lt;pattern&gt;</code>标签</h2><p><code>&lt;pattern&gt;</code>标签用于自定义一个形状，该形状可以被引用来平铺一个区域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span> <span class="attr">id</span>=<span class="string">&quot;dots&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">patternUnits</span>=<span class="string">&quot;userSpaceOnUse&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span> <span class="attr">fill</span>=<span class="string">&quot;#bee9e8&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;35&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#dots)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;pattern&gt;</code>标签将一个圆形定义为<code>dots</code>模式。<code>patternUnits=&quot;userSpaceOnUse&quot;</code>表示<code>&lt;pattern&gt;</code>的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形。</p><h2 id="标签-13"><a href="#标签-13" class="headerlink" title="&lt;image&gt;标签"></a><code>&lt;image&gt;</code>标签</h2><p><code>&lt;image&gt;</code>标签用于插入图片文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">image</span> <span class="attr">xlink:href</span>=<span class="string">&quot;path/to/image.jpg&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;image&gt;</code>的<code>xlink:href</code>属性表示图像的来源。</p><h2 id="标签-14"><a href="#标签-14" class="headerlink" title="&lt;animate&gt;标签"></a><code>&lt;animate&gt;</code>标签</h2><p><code>&lt;animate&gt;</code>标签用于产生动画效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#feac5e&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，矩形会不断移动，产生动画效果。</p><p><code>&lt;animate&gt;</code>属性含义如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attributeName；发生动画效果的属性名</span><br><span class="line">from：单次动画的初始值</span><br><span class="line">to；单次动画的结束值</span><br><span class="line">dur：单次动画的持续时间</span><br><span class="line">repeatCount：动画的循环模式</span><br></pre></td></tr></table></figure><p>可以在多个属性上面定义动画。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;width&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-15"><a href="#标签-15" class="headerlink" title="&lt;animateTransform&gt;标签"></a><code>&lt;animateTransform&gt;</code>标签</h2><p><code>&lt;animate&gt;</code>标签对 CSS 的<code>transform</code>属性不起作用，如果需要变形，就要使用<code>&lt;animateTransform&gt;</code>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;250&quot;</span> <span class="attr">y</span>=<span class="string">&quot;250&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#4bc0c8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">&quot;transform&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rotate&quot;</span> <span class="attr">begin</span>=<span class="string">&quot;0s&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;10s&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0 200 200&quot;</span> <span class="attr">to</span>=<span class="string">&quot;360 400 400&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;animateTransform&gt;</code>的效果为旋转（<code>rotate</code>），这时<code>from</code>和<code>to</code>属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标。<code>from=&quot;0 200 200&quot;</code>表示开始时，角度为0，围绕<code>(200, 200)</code>开始旋转；<code>to=&quot;360 400 400&quot;</code>表示结束时，角度为360，围绕<code>(400, 400)</code>旋转。</p><h1 id="JavaScript操作"><a href="#JavaScript操作" class="headerlink" title="JavaScript操作"></a>JavaScript操作</h1><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>如果<code>SVG</code>代码直接写在HTML网页之中，它就成为网页DOM的一部分，可以直接用DOM操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">circle &#123;</span><br><span class="line">  stroke-<span class="attribute">width</span>: <span class="number">5</span>;</span><br><span class="line">  stroke: <span class="number">#f00</span>;</span><br><span class="line">  fill: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circle<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  stroke: <span class="number">#090</span>;</span><br><span class="line">  fill: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mycircle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mycircle&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mycircle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;circle clicked - enlarging&#x27;</span>);</span><br><span class="line">  mycircle.<span class="title function_">setAttribute</span>(<span class="string">&#x27;r&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="获取SVG-DOM"><a href="#获取SVG-DOM" class="headerlink" title="获取SVG DOM"></a>获取<code>SVG DOM</code></h2><p>使用<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>标签插入 <code>SVG </code>文件，可以获取 <code>SVG DOM</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgObject = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;object&#x27;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgIframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgEmbed = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;embed&#x27;</span>).<span class="title function_">getSVGDocument</span>();</span><br></pre></td></tr></table></figure><p>注意，如果使用<code>&lt;img&gt;</code>标签插入 <code>SVG</code> 文件，就无法获取 <code>SVG DOM</code>。</p><h2 id="读取SVG源码"><a href="#读取SVG源码" class="headerlink" title="读取SVG源码"></a>读取<code>SVG</code>源码</h2><p>由于<code> SVG</code> 文件就是一段 <code>XML </code>文本，因此可以通过读取 XML 代码的方式，读取 <code>SVG </code>源码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;svg-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xml:space</span>=<span class="string">&quot;preserve&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;440&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- svg code --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>XMLSerializer</code>实例的<code>serializeToString()</code>方法，获取<code>SVG</code>元素的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgString = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>()</span><br><span class="line">  .<span class="title function_">serializeToString</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;svg&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="SVG图像转为Canvas图像"><a href="#SVG图像转为Canvas图像" class="headerlink" title="SVG图像转为Canvas图像"></a><code>SVG</code>图像转为<code>Canvas</code>图像</h2><p>首先，需要新建一个<code>Image</code>对象，将<code>SVG</code>图像指定到该<code>Image</code>对象的<code>src</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgString = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>()</span><br><span class="line">  .<span class="title function_">serializeToString</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;svg&#x27;</span>));</span><br></pre></td></tr></table></figure><p>然后，当图像加载完成后，再将它绘制到<code>&lt;canvas&gt;</code>元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了SVG图片的相关知识。</summary>
    
    
    
    <category term="SVG学习记录" scheme="http://ianblog.top/categories/SVG%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="SVG" scheme="http://ianblog.top/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——path模块</title>
    <link href="http://ianblog.top/posts/cb8d6098.html"/>
    <id>http://ianblog.top/posts/cb8d6098.html</id>
    <published>2023-05-15T01:54:23.000Z</published>
    <updated>2023-09-22T13:29:35.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node</code>中的<code>path</code>内置模块提供了操作路径的功能。·</p></blockquote><p><code>path</code>模块的引入：<code>const path = require(&#39;path&#39;)</code></p><p>下面介绍几个常用的API。</p><h2 id="resolve拼接路径"><a href="#resolve拼接路径" class="headerlink" title="resolve拼接路径"></a><code>resolve</code>拼接路径</h2><p>语法：<code>path.resolve([...paths])</code></p><p>说明：参数paths表示的是多个路径。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./index.html&quot;</span>)); </span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码\index.html 正确的路径分隔符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;index.html&quot;</span>));</span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码\index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;/index.html&quot;</span>));</span><br><span class="line"><span class="comment">// C:\index.html</span></span><br></pre></td></tr></table></figure><h2 id="sep获取系统路径分隔符"><a href="#sep获取系统路径分隔符" class="headerlink" title="sep获取系统路径分隔符"></a><code>sep</code>获取系统路径分隔符</h2><p>语法：<code>path.sep</code></p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取路径分隔符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">sep</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="parse解析路径"><a href="#parse解析路径" class="headerlink" title="parse解析路径"></a><code>parse</code>解析路径</h2><p>语法：<code>path.parse(pathName)</code></p><p>说明：参数<code>pathName</code>表示文件路径</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;C:\\Users\\learn-node\\代码\\index.html&quot;</span>; <span class="comment">// 需要转义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">parse</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   root: &#x27;C:\\&#x27;,</span></span><br><span class="line"><span class="comment">//   dir: &#x27;C:\\Users\\learn-node\\代码&#x27;,</span></span><br><span class="line"><span class="comment">//   base: &#x27;index.html&#x27;,</span></span><br><span class="line"><span class="comment">//   ext: &#x27;.html&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;index&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="basename-dirname-extname获取路径相关信息"><a href="#basename-dirname-extname获取路径相关信息" class="headerlink" title="basename/dirname/extname获取路径相关信息"></a><code>basename/dirname/extname</code>获取路径相关信息</h2><p>语法：</p><p>基础名称：<code>path.basename()</code></p><p>目录名：<code>path.dirname()</code></p><p>扩展名：<code>path.extname()</code></p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;C:\\Users\\learn-node\\代码\\index.html&quot;</span>; <span class="comment">// 需要转义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(str)); <span class="comment">// index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(str)); <span class="comment">// C:\Users\learn-node\\代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(str)); <span class="comment">// .htm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的path模块。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly主体魔改记录</title>
    <link href="http://ianblog.top/posts/2c929405.html"/>
    <id>http://ianblog.top/posts/2c929405.html</id>
    <published>2023-05-10T09:28:53.000Z</published>
    <updated>2023-09-22T13:29:35.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文中用于记录Butterfly主题的修改，以便能够快速定位。</p></blockquote><h2 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h2><p>在博客目录打开<code>Git Bush</code>，输入<code>hexo new page tags</code></p><p>找到<code>source/tags/index.md</code>文件，修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h2><p>在博客目录打开<code>Git Bush</code>，输入<code>hexo new page categories</code></p><p>找到<code>source/categories/index.md</code>文件，修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>在项目中打开终端，输入<code>npm install hexo-generator-search --save</code></p><p>在<code>_config.butterfly.yml</code>文件夹中，找到<code>local_search</code>，并修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Local search</span></span><br><span class="line">local<span class="emphasis">_search:</span></span><br><span class="line"><span class="emphasis">  enable: true</span></span><br><span class="line"><span class="emphasis">  # Preload the search data when the page loads.</span></span><br><span class="line"><span class="emphasis">  preload: false</span></span><br><span class="line"><span class="emphasis">  # Show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="emphasis">  top_</span>n<span class="emphasis">_per_</span>article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  CDN:</span><br><span class="line">  labels:</span><br><span class="line"><span class="code">    input_placeholder: Search for Posts</span></span><br><span class="line"><span class="code">    hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure><h2 id="live2d效果"><a href="#live2d效果" class="headerlink" title="live2d效果"></a>live2d效果</h2><p>在项目中打开终端，输入<code>hexo-helper-live2d--save</code>，然后安装一个你想要的模型，笔者安装的是<code>npm install live2d-widget-model-wanko --save</code>。</p><p><a href="https://github.com/xiazeyu/live2d-widget-models">模型地址</a></p><p>然后在<code>_config.yml</code>文件中添加：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#live2d</span></span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptForm: local</span><br><span class="line">  model:</span><br><span class="line"><span class="code">    use: live2d-widget-model-wanko #模型选择</span></span><br><span class="line"><span class="code">  display:</span></span><br><span class="line"><span class="code">    position: right</span></span><br><span class="line"><span class="code">    width: 180</span></span><br><span class="line"><span class="code">    height: 180</span></span><br><span class="line"><span class="code">    hOffset: 30</span></span><br><span class="line"><span class="code">    vOffset: -10</span></span><br><span class="line"><span class="code">  mobile:</span></span><br><span class="line"><span class="code">    show: false</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>enable</td><td>是否开启live2d</td></tr><tr><td>use</td><td>使用的模型</td></tr><tr><td>position</td><td>位置</td></tr><tr><td>width、height</td><td>模型大小</td></tr><tr><td>hOffset、vOffset</td><td>偏移量</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文记录了Hexo主题Butterfly的魔改。</summary>
    
    
    
    <category term="Hexo 主题魔改" scheme="http://ianblog.top/categories/Hexo-%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/"/>
    
    
    <category term="Hexo" scheme="http://ianblog.top/tags/Hexo/"/>
    
    <category term="Blog" scheme="http://ianblog.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——fs模块</title>
    <link href="http://ianblog.top/posts/95529e13.html"/>
    <id>http://ianblog.top/posts/95529e13.html</id>
    <published>2023-05-07T07:14:13.000Z</published>
    <updated>2023-09-22T06:49:56.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>的<code>fs</code>模块能够与文件系统进行交互。</p></blockquote><h2 id="fs模块介绍"><a href="#fs模块介绍" class="headerlink" title="fs模块介绍"></a><code>fs</code>模块介绍</h2><p><code>fs（File System）</code>是<code>Node.js</code>的内置模块，可以实现与硬盘的交互，例如文件的创建、删除、重命名、移动，以及文件的写入与读取。</p><p><code>fs</code>模块中的方法有同步与异步之分。</p><p>下面我将介绍<code>fs</code>模块的基本操作：</p><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>将数据保存到文件中，我们平常下载文件、安装软件的时候，就是将文件写入了磁盘中。</p><h3 id="1-writeFile异步写入"><a href="#1-writeFile异步写入" class="headerlink" title="1. writeFile异步写入"></a>1. <code>writeFile</code>异步写入</h3><p>语法：<code>fs.writeFile(file, data[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>data</code></td><td>待写入的数据</td></tr><tr><td><code>options</code></td><td>配置选项</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello Node.js&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 失败传入错误对象，成功传入null</span></span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)；</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-writeFileSync同步写入"><a href="#2-writeFileSync同步写入" class="headerlink" title="2.writeFileSync同步写入"></a>2.<code>writeFileSync</code>同步写入</h3><p>语法：<code>fs.writeFile(file, data[, options])</code></p><p>说明：参数部分与异步写入一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于没有回调函数，所以使用try catch来捕获错误</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello, Node.js&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-appendFile-appendFileSync追加写入"><a href="#3-appendFile-appendFileSync追加写入" class="headerlink" title="3. appendFile/appendFileSync追加写入"></a>3. <code>appendFile/appendFileSync</code>追加写入</h3><p>同样分为同步追加写入和异步追加写入。</p><p>语法：</p><p><code>fs.appendFile(file, data[, options], callback)</code></p><p><code>fs.appendFileSync(file, data[, options])</code></p><p>说明：参数部分与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加失败&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;\r\nhello&#x27;</span>); <span class="comment">// \r\n换行操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-creatWriteStream流式写入"><a href="#4-creatWriteStream流式写入" class="headerlink" title="4. creatWriteStream流式写入"></a>4. <code>creatWriteStream</code>流式写入</h3><p>语法：<code> fs.createWriteStream(path[, options])</code></p><p>说明：参数含义仍然一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>); <span class="comment">// 创建写入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次写入操作</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;为有源头活水来\r\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ws.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>对比：流式写入方式适用于 <strong>大文件写入</strong>或者<strong>频繁写入</strong> 的场景, <code>writeFile </code>适合于 写入频率较低的场景</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>从文件中读取数据，平时电脑开机、程序运行、播放视频、查看图片都是在读取文件。</p><h3 id="1-readFile异步读取"><a href="#1-readFile异步读取" class="headerlink" title="1. readFile异步读取"></a>1. <code>readFile异步读取</code></h3><p>语法：<code> fs.readFile(path[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>options</code></td><td>配置对象</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以utf-8字符集读取</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-readFileSync同步读取"><a href="#2-readFileSync同步读取" class="headerlink" title="2.readFileSync同步读取"></a>2.<code>readFileSync同步读取</code></h3><p>语法：<code> fs.readFileSync(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> data2 = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-creatReadStream流式读取"><a href="#3-creatReadStream流式读取" class="headerlink" title="3. creatReadStream流式读取"></a>3. <code>creatReadStream流式读取</code></h3><p>语法：<code> fs.createReadStream(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次取出 64k 数据后执行一次 data 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">length</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取完毕后, 执行 end 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件重命名与移动"><a href="#文件重命名与移动" class="headerlink" title="文件重命名与移动"></a>文件重命名与移动</h2><h3 id="rename-renameSync"><a href="#rename-renameSync" class="headerlink" title="rename/renameSync"></a><code>rename/renameSync</code></h3><p>语法：</p><p><code>fs.rename(oldPath, newPath, callback)</code></p><p><code>fs.renameSync(oldPath, newPath)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>oldPath</code></td><td>当前路径</td></tr><tr><td><code>newPath</code></td><td>新的路径</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;./abc.txt&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span>&#123; <span class="comment">// 重命名</span></span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">renameSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;../code/text.txt&#x27;</span>); <span class="comment">// 移动</span></span><br></pre></td></tr></table></figure><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p>将文件从当前目录移除。</p><h3 id="1-unlink-unlinkSync"><a href="#1-unlink-unlinkSync" class="headerlink" title="1.unlink/unlinkSync"></a>1.<code>unlink/unlinkSync</code></h3><p>语法：</p><p><code>fs.unlink(path, callback)</code></p><p><code>fs.unlinkSync(path)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>path</td><td>文件路径</td></tr><tr><td>callback</td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-rm"><a href="#2-rm" class="headerlink" title="2.rm"></a>2.<code>rm</code></h3><p>语法：<code>fs.rm(path, callback)</code></p><p>参数：与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&quot;./text.txt&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作文件夹"><a href="#操作文件夹" class="headerlink" title="操作文件夹"></a>操作文件夹</h2><h3 id="1-mkdir-mkdirSync创建文件夹"><a href="#1-mkdir-mkdirSync创建文件夹" class="headerlink" title="1. mkdir/mkdirSync创建文件夹"></a>1. <code>mkdir/mkdirSync创建文件夹</code></h3><p>语法：</p><p><code>fs.mkdir(path[, options], callback)</code></p><p><code>fs.mkdirSync(path[, options])</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>path</code></td><td>文件夹路径</td></tr><tr><td><code>options</code></td><td>配置对象</td></tr><tr><td><code>callbak</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./page&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套文件夹创建--需要配置</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a/b/c&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;递归创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;./x/y/z&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-readdir-readdirSync读取文件夹"><a href="#2-readdir-readdirSync读取文件夹" class="headerlink" title="2. readdir/readdirSync读取文件夹"></a>2. <code>readdir/readdirSync读取文件夹</code></h3><p>语法：</p><p><code>fs.readdir(path[, options], callback)</code></p><p><code>fs.readdirSync(path[, options])</code></p><p>说明：参数与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步读取</span></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./text&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 输出是个包含文件名称数组</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步读取</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readdirSync</span>(<span class="string">&#x27;./text&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure><h3 id="3-rm-rmdir删除文件夹"><a href="#3-rm-rmdir删除文件夹" class="headerlink" title="3. rm/rmdir删除文件夹"></a>3. <code>rm/rmdir删除文件夹</code></h3><p>语法：</p><p><code>fs.rm(path[, options], callback)</code></p><p><code>fs.rmdir(path[, options], callback)</code></p><p>说明：参数与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套（递归）删除</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&quot;./a&quot;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span>, <span class="attr">force</span>: <span class="literal">true</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&quot;./a&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：<code>rmdir</code>也能递归删除文件夹，但是<code>recursive</code>配置已经废弃了，所以不推荐使用。</p><h2 id="stat-statSync查看资源状态"><a href="#stat-statSync查看资源状态" class="headerlink" title="stat/statSync查看资源状态"></a><code>stat/statSync</code>查看资源状态</h2><p>语法：</p><p><code>fs.stat(path[, options], callback) </code></p><p><code>fs.statSync(path[, options])</code></p><p>说明：参数含义同上。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步获取状态</span></span><br><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">  <span class="comment">// 输出是个对象 &#123;size: xxx, birthtime: xxx, mtime: xxx, isFile: xxx, ...&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//同步获取状态</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">statSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>上述方法的第一个参数的都是指文件的路径，而文件的路径有两种写法：</p><ul><li>相对路径：<code>./a.txt</code>（当前目录下）、<code>a.text</code>（当前目录下）、<code>../a.txt</code>（上一级目录下）</li><li>绝对路径：<code>C:/a.txt</code>、<code>/a.txt</code></li></ul><p>说明：相对路径是指相对<strong>命令行的工作目录</strong>，而<em>非文件所在的目录</em>。所以在不同目录下执行文件，会出现一些问题。要想解决这个问题，要么使用绝对路径，要么使用<code>__dirname</code>（这个变量始终保存当前文件所在目录的绝对路径）拼接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/text.txt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname + <span class="string">&#x27;/text.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码/text.txt 拼接的符号不同</span></span><br></pre></td></tr></table></figure><p>当然，与<code>path</code>模块搭配使用，可以生成更加正确的路径。而且也推荐与<code>path</code>搭配使用。</p><p>nice！😀！下一篇我们将学习<code>path</code>模块！！</p>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的fs模块。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——介绍</title>
    <link href="http://ianblog.top/posts/c222fd29.html"/>
    <id>http://ianblog.top/posts/c222fd29.html</id>
    <published>2023-05-05T08:15:14.000Z</published>
    <updated>2023-09-22T04:37:32.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>使<code>JavaScript</code>具有服务端开发的能力。</p></blockquote><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是<code>Node.js</code></h2><blockquote><p><code>Node.js</code>官方给出的定义是：</p><p><code>Node.js</code>® is an open-source, cross-platform JavaScript runtime environment.</p></blockquote><p>意思是：<code>Node.js</code>是一个开源的，跨平台的<code>JavaScript</code>运行环境。通俗地说，<code>Node.js</code>其实就是一款应用程序，能够运行<code>JavaScript</code>。</p><p>Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p><p><a href="https://nodejs.org/en">下载<code>Node.js</code> </a>，推荐安装LTS（长期支持版本）</p><p>检测是否下载成功，在命令行中输入<code>node -v</code>，如果显示出版本号了，则说明安装成功。</p><h2 id="Node-js的作用"><a href="#Node-js的作用" class="headerlink" title="Node.js的作用"></a><code>Node.js</code>的作用</h2><ol><li>开发服务器应用</li><li>开发工具类应用（<code>Webpack</code>、<code>Vite</code>、<code>Babel</code>）</li><li>开发桌面端应用（<code>VScode</code>、<code>Figma</code>、<code>Postman</code>都是借助<code>electron</code>开发的）</li></ol><h2 id="Node-js的使用"><a href="#Node-js的使用" class="headerlink" title="Node.js的使用"></a><code>Node.js</code>的使用</h2><p>使用<code>Node.js</code>运行<code>JavaScript</code>代码：</p><ol><li>在你的代码目录中新建一个文件<code>hello.js</code>，输入<code>console.log(&quot;hello, Node.js&quot;)</code>，保存。</li><li>然后打开<code>VScode</code>终端（如果你的代码编辑器是<code>VScode</code>的话），输入<code>node hello.js</code>。或者你也可以直接打开<code>cmd</code>，只不过需要切换为文件所在目录。</li><li>终端上显示<code>hello, Node.js</code>。</li></ol><p>注意点：</p><ul><li><code>Node.js</code>中的<code>API</code>与浏览器中的<code>API</code>有所区别，重点是不能在<code>Node.js</code>中使用<code>DOM</code>、<code>BOM</code> （如果你在<code>Node.js</code>中输出<code>window</code>对象或者<code>document</code>对象的话，会报错）。</li><li><code>Node.js</code>当中的顶级对象是<code>global</code>或者<code>globalThis</code>（<code>ES2020</code>定义）。</li><li><code>Nodde.js</code>使用的是<code>CommonJS</code>模块，所以导入模块方式为<code>const xxx = require(&#39;xxx&#39;)</code>。</li></ul>]]></content>
    
    
    <summary type="html">本文简单介绍了Node.js。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——首部</title>
    <link href="http://ianblog.top/posts/b494c766.html"/>
    <id>http://ianblog.top/posts/b494c766.html</id>
    <published>2023-04-25T10:16:19.000Z</published>
    <updated>2023-09-23T07:53:02.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP协议的请求和响应报文中必定包含HTTP首部。本文基于图书《图解HTTP》。</p></blockquote><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>在正式介绍HTTP首部之前，我们先看一下HTTP报文的结构：</p><p>HTTP报文由报文首部、空行（CR+LF）以及报文主体组成。请求报文的首部由请求行和请求头（请求首部字段）组成；响应报文的首部由响应行和响应头（响应首部字段组成）。</p><p>请求报文示例：请求行由方法、请求URI、协议版本构成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-cn,en</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>响应报文示例：响应行由协议版本、响应状态码、响应状态字符串构成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu, 07 Jun 2012 07:21:36 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><p>从上面的示例可以看出：首部字段由首部字段名和字段值构成，中间用<code>：</code>分隔。</p><p>HTTP首部字段根据实际用途被分为4种类型：</p><ul><li><strong>通用首部字段</strong>：请求报文和响应报文都会使用的首部。</li><li><strong>请求首部字段</strong>：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li><strong>响应首部字段</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li><li><strong>实体首部字段</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li></ul><p>下面我将逐一介绍（以下的首部由HTTP1.1规范定义）：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>作用：用来控制缓存的工作机制。</p><p>使用：<code>cache-control: private, max-age=0, no-cache</code></p><p>字段值如下：</p><p>缓存请求指令：</p><table><thead><tr><th>字段值</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>强制向源服务器再次验证</td></tr><tr><td>no-store</td><td>不缓存请求或 响应的的任何内容</td></tr><tr><td>max-age&#x3D;[秒]</td><td>响应的最大的Age值</td></tr><tr><td>max-stale(&#x3D;[秒])</td><td>接收已过期的响应</td></tr><tr><td>mix-fresh&#x3D;[秒]</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>新指令标记（token）</td></tr></tbody></table><p>缓存响应指令：</p><table><thead><tr><th>字段值</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>不缓存请求或 响应的的任何内容</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>max-age&#x3D;[秒]</td><td>响应的最大Age值</td></tr><tr><td>s-maxage&#x3D;[秒]</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td>新指令标记（token）</td></tr></tbody></table><p>注意：<code>no-cache</code>代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，而<code>no-store</code>才是真正表示不进行缓存。另外<code>max-age</code>表示的是缓存的最长时间。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>作用：用来控制不再转发给代理的首部字段；用来管理持久连接。</p><p>使用：<code>Connection: Upgrade</code>   <code>Connection: Keep-Alive</code></p><p>说明：HTTP&#x2F;1.1版本默认是持久连接，所以服务器端想要明确断开连接，可以指定<code>Connection</code>的值为<code>close</code>。</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>作用：表明创建HTTP报文的日期和时间。</p><p>使用：<code>Date: Tue, 03 Jul 2023 13:40:59 GMT</code></p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>作用：提示报文主体后记录的首部字段，可应用在HTTP&#x2F;1.1版本分块传输编码时。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Trailer</span><span class="punctuation">: </span>Expires</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="language-apache"><span class="attribute">Expires</span>: Tue, <span class="number">03</span> Jul <span class="number">2023</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">59</span> GMT</span></span><br></pre></td></tr></table></figure><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>作用：规定了传输报文主体时采用的编码方式。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli">cf0</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...3312</span>字节分块数据<span class="string">...</span></span></span><br><span class="line"><span class="language-jboss-cli">392</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...914</span>字节分块数据<span class="string">...</span></span></span><br><span class="line"><span class="language-jboss-cli">0</span></span><br></pre></td></tr></table></figure><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>作用：用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>TLS/1.0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br></pre></td></tr></table></figure><p>说明：此时服务器会相应状态码为101 Switching Protocols的响应。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>作用：追踪客户端和服务器之间的请求和响应报文的传输路径以及避免请求回环的发生。</p><p>说明：报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后进行转发。</p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>作用：告知服务器，请求的资源所处的互联网主机名和端口号。</p><p>使用：<code>Host: www.abc.com</code></p><p>说明：因为相同IP地址下有可能部署运行着多个域名，所以需要Host来进行区分。这其实是因为发送请求时，请求中的主机名会用IP地址直接替换解决。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>作用：通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。使用type&#x2F;subtype的形式，一次指定多种媒体类型。</p><p>使用：<code>Accept: text/html,application/xml;q=0.9</code></p><p>说明：q表示权重值，范围为0~1，1表示权重最大。</p><p>常见的媒体类型：<code>text/html、text/plain、text/css、image/jpeg、image/gif、image/png、video/mpeg、video/quicktime</code>。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>作用：用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。</p><p>使用：<code>Accept-Charset: utf-8</code></p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>作用：用来通知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p><p>使用：<code>Accept-Encoding: gzip</code></p><p>内容编码方式有：<code>gzip、compress、deflate、identity</code></p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>作用：告知服务器用户大力能处理的自然语言集。</p><p>使用：<code>Accept-language: zh-cn,zh;q=0.7,en</code></p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的常用的HTTP首部。</summary>
    
    
    
    <category term="HTTP协议学习记录" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的闭包</title>
    <link href="http://ianblog.top/posts/7ae5b853.html"/>
    <id>http://ianblog.top/posts/7ae5b853.html</id>
    <published>2023-04-23T06:42:36.000Z</published>
    <updated>2023-09-20T02:01:42.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包是<code>Javascript</code>中一个重要的特性，使用闭包可以实现特定的需求，例如函数柯里化等。想要弄懂闭包，首先得要对执行上下文和作用域有足够的了解。</p></blockquote><h1 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h1><p>简单来说，执行上下文就是<code>Javascript</code>代码执行的环境。每个上下文都有一个关联的变量对象，在这个上下文中定义的所有变量和函数都存在于这个变量对象上。</p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul><li><strong>全局上下文</strong> ：最外层的上下文，在浏览器中指的就是<code>window</code>对象，并且用var定义的全局变量和函数会成为<code>window</code>对象的属性和方法。一个程序中只会有一个全局上下文。</li><li><strong>函数上下文</strong> ：每个函数调用都有自己的上下文。函数上下文可以有任意多个。</li><li><strong><code>Eval()</code>调用内部上下文</strong> ：执行在<code>eval</code>函数内部的代码创建属于自己的上下文。</li></ul><p><code>ECAMScript</code> 程序执行流是通过上下文栈来控制的，当代码执行流进入函数时，函数上下文会被推入栈中，当函数执行完毕时，函数上下文会被弹出栈外，将控制权返还给之前的执行上下文。</p><h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>作用域是程序中定义变量的区域，它决定了当前代码对变量的访问权限。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">//  执行函数创建变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>说明：在<code>fn</code> 函数内部创建了一个变量<code>a</code> ，但是在全局访问的时候，系统报错。可见，全局是无法获取函数内部的变量。</p><h2 id="作用域的分类"><a href="#作用域的分类" class="headerlink" title="作用域的分类"></a>作用域的分类</h2><ul><li><p><strong>全局作用域</strong> ：在全局范围内声明的变量（<strong>特殊情况</strong>：在函数中不使用关键字声明变量也会成为全局变量）处于全局作用域下，可以在程序的任意地方访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">display</span>();  <span class="comment">//  打印 0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数作用域</strong> ：也称局部作用域，在函数内部声明的变量处于函数作用域下，不能再函数以外的位置访问（闭包除外）。</p></li><li><p><strong>块级作用域</strong> ：<code>ES6</code>引入的<code>let</code>和<code>const</code> 关键字在大括号中定义的变量处于块级作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  打印 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><code>JavaScript</code> 遵循的是词法作用域。词法作用域也称静态作用域，是指变量的作用域在创建时就确定好了，而不是执行时才确定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  输出 0</span></span><br></pre></td></tr></table></figure><p>上述代码执行<code>bar</code> 函数，输出的是0，而不是1，说明在<code>bar</code>中调用<code>foo</code> ，函数<code>foo</code> 是访问不到<code>bar</code> 内部的变量。因为<code>foo</code> 处在全局作用域中，而<code>bar</code> 中的变量<code>a</code>是处在函数作用域中。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>在上面，我们知道了处在不同作用域的代码具有不同的访问权限。但是我们还不清楚访问变量是什么样的流程，访问一个变量到底是遵循什么样的规则？当有多个同名的变量可供访问时，选取哪一个？这些问题需要借助作用域链来解决。</p></blockquote><p>上下文中的代码在执行时，会创建变量对象的一个<strong>作用域链</strong>。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。作用域链的顶端（也就是第一个变量对象）<strong>始终</strong>是代码正在执行的上下文，下一个变量对象是来自包含上下文，最后一个变量对象<strong>始终</strong>是全局上下文。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索从顶端开始，逐级往后，直至搜索到标识符，或者搜索到了全局作用域为止。</p><p>看个小例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        <span class="comment">//  这里能访问color,anotherColor,tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  这里能访问color, anotherColor,但是访问不了tempColor</span></span><br><span class="line">    <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><p>上述代码涉及三个上下文，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">|__color</span><br><span class="line">|__changeColor()</span><br><span class="line">  |__anotherColor</span><br><span class="line">  |__swapColors()</span><br><span class="line">    |__tempColor</span><br></pre></td></tr></table></figure><p>内部的上下文可以访问外部上下文的变量和函数，反之不行。</p><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>有两种情况可以增强作用域链，它们都会在作用域的前端添加一个变量对象：</p><ul><li><code>try/catch</code> 语句的<code>catch</code>  块：创建一个新的变量对象，包含要抛出的错误。</li><li><code>with</code> 语句：添加一个指定的对象。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;  <span class="comment">//  块级作用域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildUrl</span>();  <span class="comment">//  ReferenceError: url is not defined</span></span><br></pre></td></tr></table></figure><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是指哪些引用了另一个函数作用域中的变量的函数，通常是在嵌套函数中实现的。看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述代码中内部函数的输出语句，引用了外部函数的变量，在这个内部函数被返回并在其他地方调用后，仍然引用着该变量。因为内部函数的作用域链包含了外部函数和全局的变量对象。</p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>闭包能够使函数在其他地方调用时，也能够访问到其外部函数的变量。这使得其在特定场景下具有重要的应用。</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数柯里化是指将一个接收多个参数的函数拆分成多个只接受单个参数的函数。其优势是能够实现参数的复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w, h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">&#125;  <span class="comment">//  求面积，但是需要一直传入宽和高，如果宽固定而高变化，就不能实现复用</span></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//  柯里化之后，内部返回新的函数只接收高</span></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getTenWidthArea</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="实现私有变量"><a href="#实现私有变量" class="headerlink" title="实现私有变量"></a>实现私有变量</h3><p>使用闭包可以轻松实现私有变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  count += val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="keyword">const</span> counter2 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  2</span></span><br><span class="line">counter1.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述函数返回包含了特权方法的对象，能够访问函数内部的私有变量以及已有方法。<code>counter1</code> 和<code>counter2</code> 分别维护各自的私有变量，互不影响。</p><p>总的来说，闭包可以延长变量的生命周期。即使外部函数执行完毕返回结果了，其活动变量并不会销毁，因为内部函数的作用域链仍有它的引用。</p><h2 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h2><p>因为闭包会保留它们包含函数额作用域，所以比其他函数更占内存。过渡使用可能导致内存过渡占用。而且在处理速度和内存消耗方面对脚本具有负面影响。因此建议仅在十分必要时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line">bar = <span class="literal">null</span>;  <span class="comment">//  解除对函数的引用，这样就可以释放内存了</span></span><br></pre></td></tr></table></figure><p>Done！😊！</p>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中闭包相关的概念</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——状态码</title>
    <link href="http://ianblog.top/posts/9abd0c3c.html"/>
    <id>http://ianblog.top/posts/9abd0c3c.html</id>
    <published>2023-04-22T06:25:15.000Z</published>
    <updated>2023-09-22T13:07:50.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP的响应状态码多达几十种，本文仅介绍具有代表性的14种。本文基于图书《图解HTTP》。</p></blockquote><h2 id="状态码的作用"><a href="#状态码的作用" class="headerlink" title="状态码的作用"></a>状态码的作用</h2><p>首先了解以下，状态码指的是什么。当服务器返回响应时，在响应报文的响应行位置会有3位数字以及原因短语组成的状态码，例如 200 OK。</p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果、标记服务器端的处理是否正常、通知出现的错误等。</p><h2 id="状态码的分类"><a href="#状态码的分类" class="headerlink" title="状态码的分类"></a>状态码的分类</h2><p>状态码有五大类：</p><table><thead><tr><th></th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>1XX</td><td>Information（信息状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><p>下面仅介绍代表性的14种：</p><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><p>2XX的响应结果表明请求被正常处理了。</p><ul><li><strong>200 OK</strong>表示从客户端发来的请求在服务器端被正常处理了。</li><li><strong>204 No Content</strong>表示服务器接收到的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</li><li><strong>206 Partial Content</strong>表示客户端进行了范围请求（Range Request），而服务器成功执行了这部分的GET请求。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>3XX的响应结果表明浏览器需要执行某些特殊的处理以正常处理请求。</p><ul><li><strong>301 Moved Permanently</strong>永久重定向，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI（响应中Location字段表明现在资源所处的URI）。</li><li><strong>302 Found</strong>临时重定向，表示请求的资源已被分配了新的URI，希望用户本次使用新的URi访问资源。</li><li><strong>303 See Other</strong>表示请求的资源存在着另一个URI，应使用<strong>GET</strong>方法定向获取请求的资源（请求方法会变为GET）。</li><li><strong>304 Not Modified</strong>表示客户端发送附带条件的请求（指的是采用GET方法的请求报文中包含了If-Match、If-Modified-Since等首部）时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器资源未改变，直接使用未过期的缓存）。</li><li><strong>307 Temporary Redirect</strong>临时重定向，与302类似，但是不会改变请求方法，例如不会从POST变成GET。</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><ul><li><strong>400 Bad Request</strong>表示请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li><li><strong>403 Forbidden</strong>表示对请求资源的访问被服务器拒绝了，例如未获得文件系统的访问权限等。</li><li><strong>404 Not Found</strong>表示服务器上无法找到请求的资源。</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX的响应结果表明服务器本身发生错误。</p><ul><li><strong>500 Internet Server Error</strong>表示服务器端在执行请求时发生了错误，可能出现了bug或者临时的故障。</li><li><strong>503 ServIce Unavailable</strong>表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><p>nice!😊！</p>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的常用的响应状态码</summary>
    
    
    
    <category term="HTTP协议学习记录" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——介绍</title>
    <link href="http://ianblog.top/posts/d5a386f7.html"/>
    <id>http://ianblog.top/posts/d5a386f7.html</id>
    <published>2023-04-19T02:12:13.000Z</published>
    <updated>2023-09-22T13:07:56.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP作为通信协议，被广泛用于客户端和服务端之间的通信流程。本文基于图书《图解HTTP》。</p></blockquote><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><blockquote><p><code>MDN</code>上对HTTP协议的解释是：<strong>HTTP</strong> 是一种用作获取诸如 HTML 文档这类资源的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>。</p></blockquote><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012?fromModule=lemma_inlink">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><p>事实上HTTP协议是<code>TCP/IP</code>协议族的一个子集，属于应用层面。那么你可能会有疑问：什么是<code>TCP/IP</code>协议族呢？</p><p>对于这个问题，要做详实的说明实在太难了，这里我只做简单说明一些知识。</p><h3 id="TCP-IP定义"><a href="#TCP-IP定义" class="headerlink" title="TCP&#x2F;IP定义"></a>TCP&#x2F;IP定义</h3><p>我们平常使用的网络就是在TCP&#x2F;IP协议族的基础上建立的。计算机与网络设备之间要相互通信，必须遵循相同的约定，比如说使用哪种语言、使用怎样的通信方式、通信的具体细节等。不同硬件、操作系统之间的通信，都需要相应的规则来进行约束，这种规则就称作协议。而TCP&#x2F;IP就是指的是互联网相关联的协议集合的总称。</p><h3 id="TCP-IP分层管理"><a href="#TCP-IP分层管理" class="headerlink" title="TCP&#x2F;IP分层管理"></a>TCP&#x2F;IP分层管理</h3><p>TCP&#x2F;IP协议族按层次分为4层，分别是应用层、传输层、网络层和数据链路层。通过分层，可以将各个职能拆分出来，比如说应用层就只关心分派给自己的任务，而不用关心传输线路与是否能传输到等问题。</p><ul><li><strong>应用层</strong>决定了向用户提供应用服务时通信的活动，处于该层的协议有FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）以及HTTP。</li><li><strong>传输层</strong>提供处于网络连接中的两台计算机之间的数据传输，处于该层的有TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</li><li><strong>网络层</strong>用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。处于该层的有IP（Internet Protocol，网际协议）。</li><li><strong>链路层</strong>用来处理连接网络的硬件部分。处于该层的有以太网协议。</li></ul><p>利用TCP&#x2F;IP进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层网上走。</p><h2 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h2><p>HTTP是一种不保存状态，即无状态协议。HTTP自身不对请求和响应之间的通信状态进行保存。</p><p><strong>PS：</strong>在HTTP&#x2F;1.1中为了实现保存状态的功能，引入了<code>Cookie</code>技术，Cookie相关的内容这里就不再赘述了，简而言之，就是服务器返回的用于标识客户端的信息。并且HTTP&#x2F;1.1也实现了持久连接（HTTP keep-alive），可以在建立一次TCP连接后进行多次请求。</p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP方法是用于告诉服务器该如何处理对应的资源。</p><p>以下方法来自HTTP&#x2F;1.1：（事实上，常用的方法就GET、POST）</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>用于请求访问已经被URI识别的资源。指定的资源经服务器端解析后返回 响应内容。</p><p>其报文形式为（现在看不懂没关系，后面会说明）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述请求将返回<code>index.html</code>的页面资源。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>用来传输实体的主体。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit.cgi</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">a</span>=<span class="number">1</span>&amp;b=<span class="number">2</span></span></span><br></pre></td></tr></table></figure><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>用来传输文件。需要配合验证，不然谁都可以进行文件上传。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560</span><br><span class="line"></span><br><span class="line"><span class="language-node-repl"><span class="meta prompt_">...</span></span></span><br></pre></td></tr></table></figure><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>用来获得报文首部。不返回响应报文主体部分，用于确认URI有效性及资源更新的日期时间等。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>用来删除文件，同样需要配合验证机制。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>用来查询针对请求URI指定资源支持的方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//请求  * 则是指对服务器进行查询</span><br><span class="line">OPTIONS * HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br><span class="line">// 响应</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span><span class="punctuation">: </span>GET,POST，HEAD，OPTIONS</span><br></pre></td></tr></table></figure><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>让Web服务器端将之前的请求通信返回给客户端的方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRACE</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span><br><span class="line"><span class="attribute">Max-Forwards</span><span class="punctuation">: </span>2</span><br></pre></td></tr></table></figure><p>响应部分</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>message/http</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1024</span><br><span class="line"></span><br><span class="line"><span class="language-http"><span class="keyword">TRACE</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span></span><br><span class="line"><span class="language-http"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span></span><br><span class="line"><span class="language-http"><span class="attribute">Max-Forwards</span><span class="punctuation">: </span>2</span></span><br></pre></td></tr></table></figure><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">proxy.def.com:8080</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.abc.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nice!😊恭喜你完成了阅读！之后会继续介绍HTTP中常用的状态码、首部、Web攻击等知识。</p>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的一些基本概念</summary>
    
    
    
    <category term="HTTP协议学习记录" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://ianblog.top/posts/925e68ec.html"/>
    <id>http://ianblog.top/posts/925e68ec.html</id>
    <published>2023-04-15T12:11:06.000Z</published>
    <updated>2023-09-20T02:01:42.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ECMAScript 2015 </code>支持<code>class</code>关键字，正式引入了类的概念。但在此之前，通过原型链以及构造函数的方式也可以模拟类的特性。</p></blockquote><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型?"></a>什么是<strong>原型</strong>?</h3><p>在 JS 中，每个函数（箭头函数除外）都会创建出一个<code>prototype</code>属性，该属性作为一个指针，指向保存了实例应该共享的属性和方法的对象。并且该对象会自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实例属性共享"><a href="#实例属性共享" class="headerlink" title="实例属性共享"></a>实例属性共享</h3><p>通过给原型对象添加属性和方法，可以被对象实例共享（这也是为什么明明对象自身没有指定的属性，但却能够读取出值来的原因）。这样做的好处是，不用给每个实例单独定义属性和方法，一劳永逸。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;ian&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">p.<span class="title function_">sayName</span>(); <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><h3 id="构造函数、原型、实例之间的关系"><a href="#构造函数、原型、实例之间的关系" class="headerlink" title="构造函数、原型、实例之间的关系"></a>构造函数、原型、实例之间的关系</h3><p>关键在于理解这一点：<strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</strong>。</p><p>使用<code>new</code>关键字创建实例，实例内部的<code>[[Prototype]]</code>指针会指向原型对象。需要说明的是：原型对象本身是<code>Object</code>的实例（如果没有重新赋值的话），所以它也有原型。如果原型是另一个类型的实例，那么实例与原型之间通过像链一样的形式连接起来，构成了<strong>原型链</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在通过对象访问属性的时候，先是会搜索对象本身，如果没找到，则会顺着指针进入原型对象，若还是没找到，则继续沿着原型链寻找，直至找到或者原型对象变为<code>null</code>（类似于变量查询的方式）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承这个概念很好理解，比如现实生活中，某某某继承了他父亲留下的亿万资产、这个小孩继承了家族优秀的基因…继承描述的就是对象获取到了什么（属性和方法）。</p></blockquote><h3 id="ES5-之前的继承方式"><a href="#ES5-之前的继承方式" class="headerlink" title="ES5 之前的继承方式"></a>ES5 之前的继承方式</h3><p>在这一阶段的继承主要是通过原型链的方式实现的。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>主要思路就是：使一个构造函数的原型对象指向另一个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lee&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 重写子类原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayName</span>); <span class="comment">// &quot;lee&quot;</span></span><br></pre></td></tr></table></figure><p>优点：这种继承方式的好处在于，子类的实例能够继承父类实例以及原型上的属性和方法。</p><p>缺点：原型中如果出现引用类型，实例之间会出现属性共享的问题（修改属性会反映到所有的实例上）；子类实例化无法给父类型传递参数。</p><h4 id="2-盗用构造函数继承"><a href="#2-盗用构造函数继承" class="headerlink" title="2. 盗用构造函数继承"></a>2. 盗用构造函数继承</h4><p>主要思路是：在子构造函数中调用父构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;sing&quot;</span>, <span class="string">&quot;dance&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;lee&quot;</span>); <span class="comment">// 调用父构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">s1.<span class="property">hobby</span>.<span class="title function_">push</span>(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobby</span>); <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;, &quot;eat&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">hobby</span>); <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：通过<code>call</code>或者<code>apply</code>方法改变<code>this</code>值，可以实现传参；并且每个实例之间有单独的属性（不共享）。</p><p>缺点：子类型无法访问到父类型原型上的属性和方法；而且要实现方法的继承，必须在构造函数中定义方法，因此函数不能重用。</p><h4 id="3-组合式继承（伪经典继承）"><a href="#3-组合式继承（伪经典继承）" class="headerlink" title="3. 组合式继承（伪经典继承）"></a>3. 组合式继承（伪经典继承）</h4><p>主要思路：结合原型链继承和盗用构造函数继承，通过原型链继承原型上的属性和方法，盗用构造函数继承实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functon <span class="title class_">Son</span>(name, age) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 继承原型方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>)</span><br><span class="line">s.<span class="title function_">sayName</span>() <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><p>优点：弥补了原型链继承和盗用构造函数继承的不足。</p><p>缺点：需要调用两次父构造函数；并且实例属性会覆盖原型上同名属性。</p><h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>主要思路：封装一个<code>object</code>函数，其中临时创建构造函数，以传入对象作为其原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); <span class="comment">// 相当于给实例指定了原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;marry&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="title function_">object</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lucas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;marry&quot;, &quot;lucas&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：不需要单独创建构造函数。</p><p>缺点：实例之间引用值共享问题。</p><h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>主要思路：其实是类似于原型式继承的，在其基础上增强了对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">creatAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title function_">object</span>(original);</span><br><span class="line">  <span class="comment">// 增强对象</span></span><br><span class="line">  obj.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">creatAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>优点：同样不需要单独创建构造函数，只关注对象。</p><p>缺点：实例之间引用值共享问题；并且通过这种方式给实例添加方法是不能重用的。</p><h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h4><p>主要思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本（寄生式继承父类原型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Son, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">object</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constuctor</span> = <span class="title class_">Son</span>; <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>, <span class="title class_">Parent</span>); <span class="comment">// 继承原型属性</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>);</span><br><span class="line">s1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">s1.<span class="title function_">sayAge</span>(); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>优点：解决了组合式继承存在的效率问题（父构造函数调用两次）；可以说是引用类型继承的最佳模式。</p><h3 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a><code>ES6</code>中的继承</h3><p><code>ES6</code>引入的<code>class</code>关键字具有正式定义类的能力。事实上，类是<code>ECMAScript</code>中的语法糖结构，其背后的思想仍然是原型和构造函数。</p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>使用<code>extends</code>关键字可以完成继承，能继承任何拥有<code>[[Constructor]]</code>和原型的对象（包括类以及构造函数）。类和原型上的方法都会都带到派生类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">prompt</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">showClass</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;&#125; <span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">prompt</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">b.<span class="title function_">prompt</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Foo&quot;</span>); <span class="comment">// &quot;Foo&quot;</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Bar&quot;</span>); <span class="comment">// &quot;Bar&quot;</span></span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>派生类的方法可以通过<code>super</code>引用它们的原型，但仅限于类构造函数、实例方法和静态方法内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">contructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">identify</span>(); <span class="comment">// &quot;ok&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>super</code>不是必须要调用的。如果没有定义类构造函数，在实例化派生类时会自动调用<code>super()</code>，而且会传入传给派生类的参数。但是如果派生类显式定义了构造函数，那么必须调用<code>super()</code>或者返回一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用super</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 返回对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中常见的实现继承的方式</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
