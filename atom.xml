<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ian Blog</title>
  
  <subtitle>好看的皮囊千篇一律，有趣的灵魂万里挑一</subtitle>
  <link href="http://ianblog.top/atom.xml" rel="self"/>
  
  <link href="http://ianblog.top/"/>
  <updated>2023-09-16T02:26:18.593Z</updated>
  <id>http://ianblog.top/</id>
  
  <author>
    <name>Ian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中的继承</title>
    <link href="http://ianblog.top/2023/04/15/JS%E7%BB%A7%E6%89%BF/"/>
    <id>http://ianblog.top/2023/04/15/JS%E7%BB%A7%E6%89%BF/</id>
    <published>2023-04-14T16:00:00.000Z</published>
    <updated>2023-09-16T02:26:18.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>ECMAScript 2015 </code>支持<code>class</code>关键字，正式引入了类的概念。但在此之前，通过原型链以及构造函数的方式也可以模拟类的特性。</p></blockquote><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型?"></a>什么是<strong>原型</strong>?</h3><p>在JS中，每个函数（箭头函数除外）都会创建出一个<code>prototype</code>属性，该属性作为一个指针，指向保存了实例应该共享的属性和方法的对象。并且该对象会自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实例属性共享"><a href="#实例属性共享" class="headerlink" title="实例属性共享"></a>实例属性共享</h3><p>通过给原型对象添加属性和方法，可以被对象实例共享（这也是为什么明明对象自身没有指定的属性，但却能够读取出值来的原因）。这样做的好处是，不用给每个实例单独定义属性和方法，一劳永逸。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;ian&quot;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>) <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">p.<span class="title function_">sayName</span>() <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><h3 id="构造函数、原型、实例之间的关系"><a href="#构造函数、原型、实例之间的关系" class="headerlink" title="构造函数、原型、实例之间的关系"></a>构造函数、原型、实例之间的关系</h3><p>关键在于理解这一点：<strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有</strong>。</p><p>使用<code>new</code>关键字创建实例，实例内部的<code>[[Prototype]]</code>指针会指向原型对象。需要说明的是：原型对象本身是<code>Object</code>的实例（如果没有重新赋值的话），所以它也有原型。如果原型是另一个类型的实例，那么实例与原型之间通过像链一样的形式连接起来，构成了<strong>原型链</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">// &#123;constructor: f Person(), __propto__: Object&#125;</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在通过对象访问属性的时候，先是会搜索对象本身，如果没找到，则会顺着指针进入原型对象，若还是没找到，则继续沿着原型链寻找，直至找到或者原型对象变为<code>null</code>（类似于变量查询的方式）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承这个概念很好理解，比如现实生活中，某某某继承了他父亲留下的亿万资产、这个小孩继承了家族优秀的基因…继承描述的就是对象获取到了什么（属性和方法）。</p></blockquote><h3 id="ES5之前的继承方式"><a href="#ES5之前的继承方式" class="headerlink" title="ES5之前的继承方式"></a>ES5之前的继承方式</h3><p>在这一阶段的继承主要是通过原型链的方式实现的。</p><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h4><p>主要思路就是：使一个构造函数的原型对象指向另一个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;lee&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 重写子类原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sayName</span>) <span class="comment">// &quot;lee&quot;</span></span><br></pre></td></tr></table></figure><p>优点：这种继承方式的好处在于，子类的实例能够继承父类实例以及原型上的属性和方法。</p><p>缺点：原型中如果出现引用类型，实例之间会出现属性共享的问题（修改属性会反映到所有的实例上）；子类实例化无法给父类型传递参数。</p><h4 id="2-盗用构造函数继承"><a href="#2-盗用构造函数继承" class="headerlink" title="2. 盗用构造函数继承"></a>2. 盗用构造函数继承</h4><p>主要思路是：在子构造函数中调用父构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hobby</span> = [<span class="string">&quot;sing&quot;</span>, <span class="string">&quot;dance&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;lee&quot;</span>) <span class="comment">// 调用父构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">s1.<span class="property">hobby</span>.<span class="title function_">push</span>(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobby</span>) <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;, &quot;eat&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2,hobby) <span class="comment">// [&quot;sing&quot;, &quot;dance&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：通过<code>call</code>或者<code>apply</code>方法改变<code>this</code>值，可以实现传参；并且每个实例之间有单独的属性（不共享）。</p><p>缺点：子类型无法访问到父类型原型上的属性和方法；而且要实现方法的继承，必须在构造函数中定义方法，因此函数不能重用。</p><h4 id="3-组合式继承（伪经典继承）"><a href="#3-组合式继承（伪经典继承）" class="headerlink" title="3. 组合式继承（伪经典继承）"></a>3. 组合式继承（伪经典继承）</h4><p>主要思路：结合原型链继承和盗用构造函数继承，通过原型链继承原型上的属性和方法，盗用构造函数继承实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functon <span class="title class_">Son</span>(name, age) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 继承原型方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>)</span><br><span class="line">s.<span class="title function_">sayName</span>() <span class="comment">// &quot;ian&quot;</span></span><br></pre></td></tr></table></figure><p>优点：弥补了原型链继承和盗用构造函数继承的不足。</p><p>缺点：需要调用两次父构造函数；并且实例属性会覆盖原型上同名属性。</p><h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4><p>主要思路：封装一个<code>object</code>函数，其中临时创建构造函数，以传入对象作为其原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>() <span class="comment">// 相当于给实例指定了原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;marry&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="title function_">object</span>(person)</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lucas&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>) <span class="comment">// &quot;ian&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>) <span class="comment">// [&quot;jack&quot;, &quot;marry&quot;, &quot;lucas&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：不需要单独创建构造函数。</p><p>缺点：实例之间引用值共享问题。</p><h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4><p>主要思路：其实是类似于原型式继承的，在其基础上增强了对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">creatAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title function_">object</span>(original)</span><br><span class="line">    <span class="comment">// 增强对象</span></span><br><span class="line">    obj.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;ian&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">creatAnother</span>(person)</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>() <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>优点：同样不需要单独创建构造函数，只关注对象。</p><p>缺点：实例之间引用值共享问题；并且通过这种方式给实例添加方法是不能重用的。</p><h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h4><p>主要思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本（寄生式继承父类原型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Son, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">object</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constuctor</span> = <span class="title class_">Son</span> <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>, <span class="title class_">Parent</span>) <span class="comment">// 继承原型属性</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;ian&quot;</span>, <span class="number">18</span>)</span><br><span class="line">s1.<span class="title function_">sayName</span>() <span class="comment">// &quot;ian&quot;</span></span><br><span class="line">s1.<span class="title function_">sayAge</span>() <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>优点：解决了组合式继承存在的效率问题（父构造函数调用两次）；可以说是引用类型继承的最佳模式。</p><h3 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a><code>ES6</code>中的继承</h3><p><code>ES6</code>引入的<code>class</code>关键字具有正式定义类的能力。事实上，类是<code>ECMAScript</code>中的语法糖结构，其背后的思想仍然是原型和构造函数。</p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>使用<code>extends</code>关键字可以完成继承，能继承任何拥有<code>[[Constructor]]</code>和原型的对象（包括类以及构造函数）。类和原型上的方法都会都带到派生类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">prompt</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">showClass</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;&#125; <span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>()</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">prompt</span>(<span class="string">&quot;foo&quot;</span>) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">b.<span class="title function_">prompt</span>(<span class="string">&quot;bar&quot;</span>) <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Foo&quot;</span>) <span class="comment">// &quot;Foo&quot;</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">showClass</span>(<span class="string">&quot;Bar&quot;</span>) <span class="comment">// &quot;Bar&quot;</span></span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>派生类的方法可以通过<code>super</code>引用它们的原型，但仅限于类构造函数、实例方法和静态方法内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">contructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>() <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">identify</span>() <span class="comment">// &quot;ok&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>super</code>不是必须要调用的。如果没有定义类构造函数，在实例化派生类时会自动调用<code>super()</code>，而且会传入传给派生类的参数。但是如果派生类显式定义了构造函数，那么必须调用<code>super()</code>或者返回一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()  <span class="comment">// 调用super</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;  <span class="comment">// 返回对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中常见的实现继承的方式</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JS" scheme="http://ianblog.top/tags/JS/"/>
    
  </entry>
  
</feed>
