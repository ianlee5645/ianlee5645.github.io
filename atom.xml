<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玻璃居</title>
  
  <subtitle>好看的皮囊千篇一律，有趣的灵魂万里挑一</subtitle>
  <link href="http://ianblog.top/atom.xml" rel="self"/>
  
  <link href="http://ianblog.top/"/>
  <updated>2023-10-05T06:32:09.142Z</updated>
  <id>http://ianblog.top/</id>
  
  <author>
    <name>Ian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保持你的思考</title>
    <link href="http://ianblog.top/posts/15ce2661.html"/>
    <id>http://ianblog.top/posts/15ce2661.html</id>
    <published>2023-09-28T04:14:38.000Z</published>
    <updated>2023-10-05T06:32:09.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自网络，侵删</p></blockquote><h2 id="你的深度思考能力，是如何一步一步被摧毁的？"><a href="#你的深度思考能力，是如何一步一步被摧毁的？" class="headerlink" title="你的深度思考能力，是如何一步一步被摧毁的？"></a>你的深度思考能力，是如何一步一步被摧毁的？</h2><p>01 前阵子，喜茶风靡全国的时候；有一次，经过一家商场，看到一家新开的喜茶，门口毫不意外地排着几十米的长队。排队的人中，男女老少均有，居然还有不少穿着正装、提着公文包的白领。有些明显赶时间，频频看表，左右张望，在原地不耐烦地跺脚。</p><p>好奇心起，我观察了一遍整个队伍，想知道他们怎么消磨时间。你猜我看到了什么？90%的人，在玩王者荣耀。是的，这两个当下最热的词汇，就这样结合在一起，毫不违和。尽管Don&apos;t judge是我的信条，但当时还是不可抑制地产生了这样的疑问：这些人为什么这么闲？为什么他们愿意把大把的时间，耗费在这些事情上面？</p><p>从心理学的角度，我可以毫不费力地列举出十几条为什么会有人愿意排队买喜茶的机制。但设身处地，真的让我排几个小时队，去买一杯奶茶，我还是会觉得，这实在是太匪夷所思了。</p><p>同样，作为一个体验过纯文字MUD的老玩家（暴露年龄），我也完全理解游戏背后的一切机制。但是，每天把几个小时的时间耗费在游戏上，这仍然会让我觉得：太奢侈了。有这么多时间，看看书，不是更好吗？</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image002.jpg"></p><p>02 1995年9月27日至10月1日，美国旧金山举行过一次会议；集合了全球500多位政治、经济精英，包括撒切尔、老布什、各大顶尖企业的董事长，等等。会议的主题是什么呢？如何应对全球化？</p><p>会上，与会者一致认为，全球化会加剧贫富差距，会使财富集中在全球20%的人手上，而另外80%的人被边缘化。那么，如何化解这80%的人和20%精英之间的冲突？如何消解这80%人口的多余精力和不满情绪，转移他们的注意力？</p><p>当时的美国高级智囊布热津斯基认为，唯一的方法，是给这80%的人口，塞上一个奶嘴。让他们安于为他们量身订造的娱乐信息中，慢慢丧失热情、抗争欲望和思考的能力。他说：公众们将会在不久的将来，失去自主思考和判断的能力。最终他们会期望媒体为他们进行思考，并作出判断。</p><p>这就是闻名遐迩的<code>Tittytainment</code> 战略，由<code>Titty（奶嘴）</code>与 <code>Entertainment（娱乐）</code>合成，中文译为奶头乐（有点三俗的译法）。奶头乐战略，具体是什么呢？</p><p>一、是发展发泄性的产业具体而言，包括色情业、赌博业，发展暴力型影视剧、游戏，集中报道无休止的口水战、纠纷冲突，等等，让大众将多余的精力发泄出来。</p><p>二、是发展满足性的产业包括报道连篇累牍的无聊琐事：娱乐圈新闻、明星花边、家长里短，发展廉价品牌，各种小恩小惠的活动，以及偶像剧、综艺等大众化娱乐产业，让大众沉溺于享乐和安逸中，从而丧失上进心和深度思考能力。</p><p>一言以蔽之，那些被边缘化的人，只需要给他们一口饭吃，一份工作，让他们有东西可看，便会沉浸在快乐之中，无心挑战现有的统治阶级。这个战略成功了吗？目前来看，挺成功的。  </p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image004.jpg">  </p><p>03 是的，我说的就是一切偶像剧、明星、娱乐圈、微博热搜、暴力冲突、情绪煽动、阶级对立、低幼化游戏。我们日常的视野中，充斥着这些信息。但这其中，99%的东西，与我们一点关系都没有，对我们也没有哪怕一丁点价值。</p><p>微博热搜，可以买，可以冲，给够营销团队的钱，想上什么就上什么。百度新闻，绝大多数是标题党，不是哪个明星出了新戏，就是谁谁又闹了绯闻。更别说今日头条之类的资讯平台、和朋友圈里疯传的各种推送了。奇葩说第一季刚出来的时候，眼前一亮，毕竟算是一档有价值和内涵的综艺，非常难得。但看了几期之后，你会慢慢发现，思辨开始让位于煽情，逻辑永远辩不过故事。</p><p>看实时投票，感受最鲜明的是：观众并不在乎逻辑，并不关心谁说得有理，他们只关心谁说得更声情并茂。通常背景音乐一转，开始变成钢琴独奏，情绪酝酿起来了，票数就开始变化了。那群选手里面，我比较欣赏的，是陈铭。</p><p>无论是思考的角度，还是逻辑论证，单单论表现来说，都高出其他人不止一个档次。当然，并不意味着其他人水平不高，很可能只是选择的路线和策略不同而已。但节目组苦心孤诣，一定要给陈铭安上鸡汤王的标签；每次他起立发言，马薇薇总会扯一句：又开始在世界中心呼唤爱了。如果我是陈铭，我想，我一定不会喜欢这种感受，因为这是一种曲解和侮辱。</p><p>但为什么会这样呢？因为观众只能理解这些。最近，知乎在讨论一个话题：如何看待越来越多的大V，靠爆照、编故事、抄袭段子起家，拿到几千、几万的关注？有人说得很好：同一个人，爆照回答1000赞，写情感故事1000赞，科普专业知识、还得到编辑推荐和一帮大V点赞的回答，才不到100赞。如果是你，你会怎么选？麦克卢汉说过一句话：我们创造了工具，工具反过来塑造我们。在这里，也是一样的：我们选择了怎样的媒体，媒体就用怎样的方式塑造我们。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image006.jpg"> </p><p> 04 无独有偶，大前研一在《低智商社会》中提到，日本的新一代，正在逐渐步入低智商社会。他们读的书越来越幼稚，对各种谣言丝毫不会思考，很容易遭到媒体的操纵，得过且过、毫无斗志……他甚至提到一个事情：通过安保斗争，日本政府认识到，如果对过激的学生运动放任不管的话，就会导致政府下台，所以政府就从此开始实行愚民政策。</p><p>这其中的代表性举措，就是推行偏差值教育制度。大前研一这样解释道：由于偏差值制度的实行，人的能力被数字化了，所以日本的学生经常会被问到你的偏差值是多少这样的问题。所以他们在这个时代是不会有危机意识的。因为在他们的意识里，这个社会将来不管发生了什么事，都将由那些高偏差值的人来解决。</p><p>自己用不着去浪费脑细胞，只要按照别人说的去做就可以了。他们习惯于在同一班级或者是同一年级组中作比较，然后认为那些高偏差值的人，理所当然地就应该去政府部门工作。</p><p>同样，能进入媒体工作的人也被认为是高偏差值的人。所以，他们认为政府所做的一切决策都是对的，媒体所说的话也全都是可信的。日本社会的现状就是这样。人人都把政府和媒体当做自己生活的指南。他们根本就不会去思考和反思。</p><p>这岂非也是另一种层面的奶头乐？通过阻断你的希望，让你活在别人为你设定好的框架里，停止思考，失去独立的能力，越来越依赖于环境。 </p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image008.jpg"></p><p> 05 私下里，我跟一帮朋友聊天的时候（嗯，就是大家熟悉的高太爷、曾少贤、孙圈圈……），大家都会说：我们选择了 Hard 模式。因为，愿意深入思考，愿意看我们文章的人，本来就是小众。大众喜闻乐见的是什么呢？</p><p>情绪，观点，立场，站队，看文章就是为了放松的，最好别让我再去用脑子。毕竟，在我们生活中，有着太多太多被人为创造出来，来吸引我们注意力的东西：偶像剧，大片，综艺，娱乐圈花边，网络游戏，热点消息，诸如此类。我们每天光是保持专注，其实，就已经是一件很困难的事情。</p><p>拿热点资讯来说。一条 APP 推送，背后都是一个运营团队，群策群力，经过初稿、初审、复审等一堆环节，有着专业的消费者行为学作支撑，用尽各种文案技法，目的是什么呢？就是吸引你的注意力，点进去。同样，一款网络游戏，背后可能是几百人的团队，用最前沿的科技，最详尽的数据，通过声、光、交互、反馈等全方位途径，在各种心理学、行为经济学、认知神经科学等理论指导下，精心打造,目的是什么？为了创造一个虚拟空间，来消磨你的时间。</p><p>一个综艺节目，背后可能是精确到秒的台本，现场五六个机位，多次的彩排、训练，从场景到灯光到音乐，再到人物的服装、语气、动作，全部精心调制。目的就是为了让你沉浸进去，在观看的时候，忘掉时间的流逝。而反过来，无论是学习、阅读、思考、写作，这些事情，哪一件有着这么强大的阵势？将触及成本降到这么低？不存在的。这就是消费娱乐文化为我们创造的牢笼，而我们正心满意足地，一步步走进去。 </p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image010.jpg"> </p><p> 06 当然，我并不反对适当的娱乐，否则活得也太累了些。但是，更常见的现象是什么呢？下班了，一身疲惫，想着今晚要学习，忍不住还是把手伸向了手机，刷起微博，玩起王者荣耀。放下手机已是深夜，一边告诉自己明天再努力吧，一边洗澡、洗漱，然后睡觉。第二天，重复着跟前一天一模一样的生活。这是很正常的。</p><p>前文讲过，一切娱乐产品：影视剧、综艺、游戏，它们背后有着庞大的团队。这些团队的唯一目的，就是用尽各种手段，去降低你触及它们的阻力。它们会在你视野中不断出现，用各种资讯、消息提醒你，诱导你去点击。一旦点击了，就再也不会给你机会离开。想一想，你已经有多久，没有真正为自己的目标做过一些事情了？</p><p>这里面最严重的是什么呢？一旦你习惯了这种低成本、高回报的刺激，你就很难去做那些高投入的事情了。人的阈值，是会不断升高的。所以，这个时代，我们似乎很难再产生情绪的波动，很难去投入到一样东西上面，很难专注去做一件事情。因为，我们的大脑已经被周围的环境，塑造成了一个高刺激阈值的对象。习惯了轻而易举能获得大量愉悦感，你就会慢慢对这种愉悦感脱敏。久而久之，这种强度的愉悦感已经满足不了你了，你需要更高强度、更持续、更深入的刺激。</p><p>相对而言，愉悦感更少、付出更高的行为：比如学习，阅读，思考：自然也就没有人愿意去做。这样下去会有什么后果？公众们将会在不久的将来，失去自主思考和判断的能力。最终他们会期望媒体为他们进行思考，并作出判断。这是一个很可怕的事情。  </p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/clip_image012.jpg"> </p><p> 07 最后，我想给你几个建议：</p><ol><li>拒绝低幼化的语言刺激什么是低幼化的语言刺激？绝大多数的网络流行语都是。诸如我也是醉了666扎心你看这个面，它又长又宽……为什么这样说？因为，语言塑造了我们的思维。我并不是说牛逼就一定不如厉害优秀出色：但如果有一天，我们要表达厉害，只会说牛逼，这岂不是很可怕？日常生活中，尽量拨出一定的时间，看深度的、优秀的书籍和文章，保持自己对语言的理解和运用能力。谁掌握了语言，谁就掌握了思想。</li><li>拒绝抢夺注意力的低劣产品如果可以，拒绝从众，拒绝那些肤浅的综艺、影视剧、热点消息、娱乐圈资讯，只看最优秀的作品。什么是最优秀的作品？至少，是有突破性的，不反智的，引发思考的，有诚意的，需要动脑子的：《黑镜》就很不错，《权力的游戏》也还可以。不要让自己成为愉悦感的奴隶。不动脑子，能带来短期的愉悦和轻松，但长期来看，它只能导向空虚和无聊。</li><li>为自己设定有意义的目标找到一件有长期收益的事情，并从中获得幸福感这是一件你需要在30岁前做到的事。很多人问我：你不看剧，不看电影，不看综艺，不聚会，不玩游戏，你平时究竟都干些什么？我说：学习啊。他们问：不会觉得无聊吗？每每获得一个新知识，每每将新知识纳入自己的思维体系，所带来的快感是无与伦比的，怎么会感到无聊呢？所以，请找到一件能够带给你长期收益和幸福感的事情，把它安排进每天的日程中。不需要追求物质收益，也不需要苛求成为领域专家，它的意义，是帮助你对抗慵常、平凡、索然无味的日常生活，让你保持头脑的清醒。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章转载自网络，侵删&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;你的深度思考能力，是如何一步一步被摧毁的？&quot;&gt;&lt;a href=&quot;#你的深度思考能力，是如何一步一步被摧毁的？&quot; class=&quot;headerlink&quot; title=&quot;你的深度思</summary>
      
    
    
    
    <category term="随心记（水星记）" scheme="http://ianblog.top/categories/%E9%9A%8F%E5%BF%83%E8%AE%B0%EF%BC%88%E6%B0%B4%E6%98%9F%E8%AE%B0%EF%BC%89/"/>
    
    
    <category term="notes" scheme="http://ianblog.top/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router相关知识</title>
    <link href="http://ianblog.top/posts/683bcb01.html"/>
    <id>http://ianblog.top/posts/683bcb01.html</id>
    <published>2023-07-26T13:25:26.000Z</published>
    <updated>2023-09-24T11:22:17.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vue Router 是 <a href="https://vuejs.org/">Vue.js</a> 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。</p></blockquote><h2 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key是路径，value是组件。</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意点</strong></p><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h2 id="多级路由（多级路由）"><a href="#多级路由（多级路由）" class="headerlink" title="多级路由（多级路由）"></a>多级路由（多级路由）</h2><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h2><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h2><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h2><p>​作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="的replace属性"><a href="#的replace属性" class="headerlink" title="&lt;router-link&gt;的replace属性"></a><code>&lt;router-link&gt;</code>的replace属性</h2><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h2><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由器的两种工作模式"><a href="#路由器的两种工作模式" class="headerlink" title="路由器的两种工作模式"></a>路由器的两种工作模式</h2><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Vue Router相关知识。</summary>
    
    
    
    <category term="Vue学习记录" scheme="http://ianblog.top/categories/Vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Vue" scheme="http://ianblog.top/tags/Vue/"/>
    
    <category term="Vue Router" scheme="http://ianblog.top/tags/Vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>vuex相关知识</title>
    <link href="http://ianblog.top/posts/34f48358.html"/>
    <id>http://ianblog.top/posts/34f48358.html</id>
    <published>2023-07-23T06:15:34.000Z</published>
    <updated>2023-09-24T11:22:17.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h2 id="搭建vuex环境"><a href="#搭建vuex环境" class="headerlink" title="搭建vuex环境"></a>搭建vuex环境</h2><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line"><span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">state.<span class="property">sum</span> += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote><h2 id="getters的使用"><a href="#getters的使用" class="headerlink" title="getters的使用"></a>getters的使用</h2><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h2 id="映射方法"><a href="#映射方法" class="headerlink" title="映射方法"></a>映射方法</h2><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h2 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h2><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了Vuex的相关知识。</summary>
    
    
    
    <category term="Vue学习记录" scheme="http://ianblog.top/categories/Vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Vue" scheme="http://ianblog.top/tags/Vue/"/>
    
    <category term="Vuex" scheme="http://ianblog.top/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue2相关知识</title>
    <link href="http://ianblog.top/posts/a4190fa8.html"/>
    <id>http://ianblog.top/posts/a4190fa8.html</id>
    <published>2023-07-15T02:24:36.000Z</published>
    <updated>2023-09-24T11:33:00.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。</p><p>本文介绍的是Vue2.0。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/vue.jpg"></p><h2 id="初始Vue"><a href="#初始Vue" class="headerlink" title="初始Vue"></a>初始Vue</h2><h3 id="Vue的安装："><a href="#Vue的安装：" class="headerlink" title="Vue的安装："></a>Vue的安装：</h3><p><code>html</code>中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>npm</code>：<code>npm install vue@^2</code></p><p><a href="https://cli.vuejs.org/"><code>vue-cli</code></a></p><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><p>想让<code>Vue</code>工作，就必须创建一个<code>Vue</code>实例，且要传入一个配置对象；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>, <span class="comment">// 表示要挂载的元素</span></span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="comment">// 数据</span></span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最终<code>#app</code>盒子里面内容渲染为：<code>Hello Vue!</code></p><p>说明：</p><ul><li><code>#app</code>容器里的代码依然符合<code>html</code>规范，只不过混入了一些特殊的<code>Vue</code>语法；</li><li><code>#app</code>容器里的代码被称为【<code>Vue</code>模板】；</li><li><code>Vue</code>实例和容器是一一对应的；</li><li>开发中只有一个<code>Vue</code>实例，并且会配合着组件一起使用；</li><li><code>&#123;&#123;xxx&#125;&#125;</code>中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</li><li>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</li></ul><p>注意区分：js表达式 和 js代码(语句)<br>    1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：<br>        (1). a<br>        (2). a+b<br>        (3). <code>demo(1)</code><br>        (4). <code>x === y ? &#39;a&#39; : &#39;b&#39;</code></p><pre><code>2. js代码(语句)    (1). `if()&#123;&#125;`    (2). `for()&#123;&#125;`</code></pre><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Vue模板语法有2大类：</p><ul><li>插值语法：<ul><li>功能：用于解析标签体内容。</li><li>写法：<code>&#123;&#123;xxx&#125;&#125;</code>，xxx是js表达式，且可以直接读取到data中的所有属性。</li></ul></li><li>指令语法：<ul><li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</li><li>举例：<code>v-bind:href=&quot;xxx&quot;</code> 或  简写为 <code>:href=&quot;xxx&quot;</code>，xxx同样要写js表达式，</li></ul></li></ul><p>​                   且可以直接读取到data中的所有属性。</p><p>​    备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>Vue中有2种数据绑定的方式：</p><ul><li><p>单向绑定(<code>v-bind</code>)：数据只能从data流向页面。</p></li><li><p>双向绑定(<code>v-model</code>)：数据不仅能从data流向页面，还可以从页面流向data。</p><p> 备注：</p></li><li><p>双向绑定一般都应用在表单类元素上（如：<code>input</code>、<code>select</code>等）</p></li><li><p><code>v-model:value </code>可以简写为<code> v-model</code>，因为<code>v-model</code>默认收集的就是<code>value</code>值。</p></li></ul><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><p>data与el的2种写法</p><ul><li><p>el有2种写法</p><ul><li>new Vue时候配置el属性。</li><li>先创建Vue实例，随后再通过<code>vm.$mount(&#39;#root&#39;)</code>指定el的值。</li></ul></li><li><p>data有2种写法</p><ul><li>对象式</li><li>函数式</li></ul></li></ul><p><em>如何选择</em>：组件当中data必须使用函数式，否则会报错。</p><p><strong>一个重要的原则</strong>：</p><p>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。但是非管理的函数，建议写成箭头函数，因为this可以指向实例</p><h2 id="Vue中的MVVM模型"><a href="#Vue中的MVVM模型" class="headerlink" title="Vue中的MVVM模型"></a>Vue中的MVVM模型</h2><p>MVVM模型：</p><ul><li><p>M：模型(Model) ：data中的数据</p></li><li><p>V：视图(View) ：模板代码</p></li><li><p>VM：视图模型(ViewModel)：Vue实例</p></li></ul><p>观察发现：</p><ul><li><p>data中所有的属性，最后都出现在了vm身上。</p></li><li><p>vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p></li></ul><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读&#x2F;写）</p><p><em>Vue中的数据代理</em>：</p><p>通过vm对象来代理data对象中属性的操作（读&#x2F;写）  所以vm中有data中得属性，并且可以对其操作。</p><p><em>Vue中数据代理的好处</em>：</p><p> 更加方便的操作data中的数据。</p><p><em>基本原理</em>：</p><p>通过<code>Object.defineProperty()</code>把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个<code>getter/setter</code>。在<code>getter/setter</code>内部去操作（读&#x2F;写）data中对应的属性。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>事件的基本使用：</p><ul><li><p>使用<code>v-on:xxx </code>或 <code>@xxx </code>绑定事件，其中xxx是事件名；</p></li><li><p>事件的回调需要配置在methods对象中，最终会在vm上；</p></li><li><p>methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p></li><li><p>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p></li><li><p><code>@click=&quot;demo&quot; </code>和 <code>@click=&quot;demo($event)&quot; </code>效果一致，但后者可以传参；</p></li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>Vue中的事件修饰符：</p><ul><li><p>prevent：阻止默认事件（常用）；</p></li><li><p>stop：阻止事件冒泡（常用）；</p></li><li><p>once：事件只触发一次（常用）；</p></li><li><p>capture：使用事件的捕获模式；</p></li><li><p>self：只有<code>event.target</code>是当前操作的元素时才触发事件；</p></li><li><p>passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p></li></ul><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>Vue中常用的按键别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">回车 =&gt; enter</span><br><span class="line">删除 =&gt; delete (捕获“删除”和“退格”键)</span><br><span class="line">退出 =&gt; esc</span><br><span class="line">空格 =&gt; space</span><br><span class="line">换行 =&gt; tab (特殊，必须配合keydown去使用)</span><br><span class="line">上 =&gt; up</span><br><span class="line">下 =&gt; down</span><br><span class="line">左 =&gt; left</span><br><span class="line">右 =&gt; right</span><br></pre></td></tr></table></figure><p>Vue未提供别名的按键，可以使用按键<strong>原始的key值</strong>去绑定，但注意要转为kebab-case（短横线命名）<br><strong>系统修饰键（用法特殊）</strong>：ctrl、alt、shift、meta</p><ul><li><p>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p></li><li><p>配合keydown使用：正常触发事件。</p><p><code>Vue.config.keyCodes.</code>自定义键名 &#x3D; 键码，可以去自定义按键别名</p></li></ul><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>定义：要用的属性不存在，要通过已有属性计算得来。</p><p>原理：底层借助了<code>Objcet.defineproperty</code>方法提供的<code>getter和setter</code>。</p><p>提问：get函数什么时候执行？</p><ul><li><p>初次读取时会执行一次。</p></li><li><p>当依赖的数据发生改变时会被再次调用。</p></li></ul><p>补充说明：</p><ul><li><p>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p></li><li><p>计算属性最终会出现在vm上，直接读取使用即可。</p></li><li><p>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p></li></ul><p>写法示例：<em>简写意味着只读取值，而不修改值  当只有getter的时候才有简写形式。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line"><span class="comment">//完整写法</span></span><br><span class="line"><span class="comment">/* fullName:&#123;</span></span><br><span class="line"><span class="comment">get()&#123;</span></span><br><span class="line"><span class="comment">console.log(&#x27;get被调用了&#x27;)</span></span><br><span class="line"><span class="comment">return this.firstName + &#x27;-&#x27; + this.lastName</span></span><br><span class="line"><span class="comment">&#125;,</span></span><br><span class="line"><span class="comment">set(value)&#123;</span></span><br><span class="line"><span class="comment">console.log(&#x27;set&#x27;,value)</span></span><br><span class="line"><span class="comment">const arr = value.split(&#x27;-&#x27;)</span></span><br><span class="line"><span class="comment">this.firstName = arr[0]</span></span><br><span class="line"><span class="comment">this.lastName = arr[1]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="comment">//简写意味着只读取值，而不修改值  当只有getter的时候才有简写形式</span></span><br><span class="line"><span class="title function_">fullName</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get被调用了&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h2><p>特点：当被监视的属性变化时, 回调函数自动调用, 进行相关操作,可以用于执行一些超时逻辑，例如定时器。</p><p>条件：监视的属性必须存在，才能进行监视！！</p><p>写法：</p><ul><li><p><code>new Vue</code>时传入watch配置</p></li><li><p>通过<code>vm.$watch</code>监视</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* watch:&#123;</span></span><br><span class="line"><span class="comment">isHot:&#123;</span></span><br><span class="line"><span class="comment">immediate:true, //初始化时让handler调用一下</span></span><br><span class="line"><span class="comment">//handler什么时候调用？当isHot发生改变时。</span></span><br><span class="line"><span class="comment">handler(newValue,oldValue)&#123;</span></span><br><span class="line"><span class="comment">// 可以有些处理逻辑在这</span></span><br><span class="line"><span class="comment">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">immediate</span>:<span class="literal">true</span>, <span class="comment">//初始化时让handler调用一下</span></span><br><span class="line"><span class="comment">//handler什么时候调用？当isHot发生改变时。</span></span><br><span class="line"><span class="title function_">handler</span>(<span class="params">newValue,oldValue</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><ol><li><p>class样式：写法<code>:class=&quot;xxx&quot; </code>xxx可以是字符串、对象、数组。</p><p>字符串写法适用于：类名不确定，要动态获取。</p><p>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p><p>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 v-bind指令--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;mood&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeMood&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>style样式：</p><p><code>:style=&quot;&#123;fontSize: xxx&#125;&quot;</code>其中xxx是动态值。</p><p><code>:style=&quot;[a,b]&quot;</code>其中a、b是样式对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 绑定style样式--数组写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol><li><p>v-if：</p><p>写法：</p><p> (1).v-if&#x3D;”表达式” </p><p> (2).v-else-if&#x3D;”表达式”</p><p> (3).v-else&#x3D;”表达式”</p><p> 适用于：切换频率较低的场景。</p><p>  特点：不展示的DOM元素直接被移除。</p><p>  注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;false&quot;</span>&gt;</span>欢迎来到&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;1 === 1&quot;</span>&gt;</span>欢迎来到&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-show：</p><p>写法：v-show&#x3D;”表达式”</p><p>适用于：切换频率较高的场景。</p><p>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;false&quot;</span>&gt;</span>欢迎来到&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;1 === 1&quot;</span>&gt;</span>欢迎来到&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p></li></ol><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>v-for指令:</p><p><strong>语法</strong>：<code>v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</code>  key一定得加，因为diff算法需要用到</p><p> 范围：可遍历数组、对象、字符串（用的很少）、指定次数（用的很少）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,k) of car&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;k&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;k&#125;&#125;-&#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="key值的原理"><a href="#key值的原理" class="headerlink" title="key值的原理"></a>key值的原理</h3><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,  随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><p>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>​  ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>​  ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p><p> (2).旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM，随后渲染到到页面。</p><p>注意事项： 用<code>index</code>作为key可能会引发的问题：</p><p> (1).若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p><p> (2).如果结构中还包含输入类的DOM：</p><p>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题（比如每个列表项前面有个<code>input</code>框）。</p><p><em>如何选择key?:</em></p><p>1.最好使用每条数据的唯一标识作为key, 比如<strong>id</strong>、手机号、身份证号、学号等唯一值。<br>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。</p><h3 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用watch实现</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">keyWord</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">persons</span>:[</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">], <span class="comment">//存储原始数据</span></span><br><span class="line"><span class="attr">filPerons</span>:[] <span class="comment">//存储过滤后的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="attr">keyWord</span>:&#123;</span><br><span class="line"><span class="comment">//先调用一遍   不先调用的话，filPersons的值就是个空数组了</span></span><br><span class="line"><span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="title function_">handler</span>(<span class="params">val</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">filPerons</span> = <span class="variable language_">this</span>.<span class="property">persons</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.<span class="property">name</span>.<span class="title function_">indexOf</span>(val) !== -<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用computed实现</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="comment">// 双向数据绑定获得输入的值</span></span><br><span class="line"><span class="attr">keyWord</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="attr">persons</span>:[</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line"><span class="comment">// 用计算属性去过滤数组</span></span><br><span class="line"><span class="title function_">filPerons</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">persons</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 如果没有的话，就返回-1    检索空的字符串 返回的是0</span></span><br><span class="line"><span class="keyword">return</span> p.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">keyWord</span>) !== -<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 2&quot;</span>&gt;</span>年龄升序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 1&quot;</span>&gt;</span>年龄降序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 0&quot;</span>&gt;</span>原顺序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 然后根据类型进行`sort`操作</span><br></pre></td></tr></table></figure><h3 id="数组更新中的问题"><a href="#数组更新中的问题" class="headerlink" title="数组更新中的问题"></a>数组更新中的问题</h3><p>对于数组，要想获取响应式的更新，必须使用<code>vue</code>包装过的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"><span class="title function_">updateMei</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">persons</span>[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;马老师&#x27;</span> <span class="comment">//奏效   是对数组里面的对象进行的操作 所以是奏效的</span></span><br><span class="line"><span class="comment">// this.persons[0].age = 50 //奏效</span></span><br><span class="line"><span class="comment">// this.persons[0].sex = &#x27;男&#x27; //奏效</span></span><br><span class="line"><span class="comment">// 不能直接对数组元素进行操作，可以用数组方法修改数组</span></span><br><span class="line"><span class="comment">// this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效</span></span><br><span class="line"><span class="comment">// this.persons.splice(0,1,&#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125;)   使用特定的数组方法才奏效</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue检测数据改变的原理-对象"><a href="#Vue检测数据改变的原理-对象" class="headerlink" title="Vue检测数据改变的原理_对象"></a>Vue检测数据改变的原理_对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue有一个Observer构造函数,获得所有的键，然后调用Object.defineProperty  对data加工之后再赋值（定义getter  和setter 在setter里面重新解析模板）</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;ian&#x27;</span>,</span><br><span class="line"><span class="attr">address</span>:<span class="string">&#x27;changsha&#x27;</span>,</span><br><span class="line"><span class="attr">student</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:&#123;</span><br><span class="line"><span class="attr">rAge</span>:<span class="number">40</span>,</span><br><span class="line"><span class="attr">sAge</span>:<span class="number">29</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">friends</span>:[</span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;jerry&#x27;</span>,<span class="attr">age</span>:<span class="number">35</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue-set的使用"><a href="#Vue-set的使用" class="headerlink" title="Vue.set的使用"></a>Vue.set的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给某个数据中加属性  并且是响应式的</span></span><br><span class="line"><span class="comment">// Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)</span></span><br><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">student</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Vue检测数据改变的原理-数组"><a href="#Vue检测数据改变的原理-数组" class="headerlink" title="Vue检测数据改变的原理_数组"></a>Vue检测数据改变的原理_数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue里面包装了关于数组的方法（重写了对应的方法）</span></span><br><span class="line"><span class="comment">//push()、pop()、shift()、unshift()、splice()、sort()、reverse()</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue监视数据的原理：</p><ol><li><p>vue会监视data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？</p><p>通过setter实现监视，且要在new Vue时就传入要监测的数据。<br>(1).对象中后追加的属性，Vue默认不做响应式处理<br>(2).如需给后添加的属性做响应式，请使用如下API：</p><ul><li><code>Vue.set(target，propertyName/index，value) </code></li><li><code>vm.$set(target，propertyName/index，value)</code></li></ul></li><li><p>如何监测数组中的数据？</p><p>通过包裹数组更新元素的方法实现，本质就是做了两件事：<br>(1).调用原生对应的方法对数组进行更新。<br>(2).重新解析模板，进而更新页面。</p></li><li><p>在Vue修改数组中的某个元素一定要用如下方法：<br>1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>    2.Vue.set() 或 vm.$set()<br>        只能给data里面某个属性追加属性，不能给data对象加属性<br><strong>特别注意</strong>：<code>Vue.set()</code> 和<code>vm.$set()</code>不能给vm 或 vm的根数据对象(data) 添加属性！！！</p></li></ol><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p>收集表单数据：</p><ul><li><code>&lt;input type=&quot;text&quot;/&gt;</code>，v-model收集的是value值，用户输入的就是value值。</li><li><code>&lt;input type=&quot;radio&quot;/&gt;</code>，v-model收集的是value值，且要给标签<strong>配置</strong>value值。</li><li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code><ul><li>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li><li>配置input的value属性:<ul><li>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li><li>v-model的初始值是数组，那么收集的的就是value组成的数组</li></ul></li></ul></li></ul><p><strong>注意</strong>：v-model的三个修饰符：</p><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>lazy</td><td>失去焦点再收集数据</td></tr><tr><td>number</td><td>输入字符串转为有效的数字</td></tr><tr><td>trim</td><td>输入首尾空格过滤</td></tr></tbody></table><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>语法：</p><ul><li>注册过滤器：<code>Vue.filter(name,callback)</code> 或 <code>new Vue&#123;filters:&#123;&#125;&#125;</code></li><li>使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或  <code>v-bind:属性 = &quot;xxx | 过滤器名&quot;</code></li></ul><p>注意：</p><ul><li>过滤器也可以接收额外参数、多个过滤器也可以串联</li><li>并没有改变原本的数据, 是产生新的对应的数据</li></ul><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><p>上面已经提及到的指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>单向绑定解析表达式, 可简写为 :xxx</td></tr><tr><td>v-model</td><td>双向数据绑定</td></tr><tr><td>v-for</td><td>遍历数组&#x2F;对象&#x2F;字符串</td></tr><tr><td>v-on</td><td>绑定事件监听, 可简写为@</td></tr><tr><td>v-if</td><td>条件渲染（动态控制节点是否存存在）</td></tr><tr><td>v-else</td><td>条件渲染（动态控制节点是否存存在）</td></tr><tr><td>v-show</td><td>条件渲染 (动态控制节点是否展示)</td></tr></tbody></table><p>补充指令：</p><p><strong>v-text指令</strong>：</p><ul><li>作用：向其所在的节点中渲染文本内容。</li><li>与插值语法的区别：v-text会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。  v-text不能识别出html标签</li></ul><p><strong>v-html指令</strong>：</p><ul><li>作用：向指定节点中渲染包含html结构的内容。</li><li>与插值语法的区别：<br>(1).v-html会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。<br>(2).v-html可以识别html结构。</li><li>严重注意：v-html有安全性问题！！！！<br>(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。<br>(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li></ul><p></p><p><strong>v-cloak指令（没有值）</strong>：</p><ul><li><p>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p></li><li><p>使用css配合v-cloak可以解决网速慢时页面展示出<code>&#123;&#123;xxx&#125;&#125;</code>的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line"><span class="comment">/* 方括号里面包含指令  然后隐藏 */</span></span><br><span class="line"><span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>v-once指令</strong>：</p><ul><li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li><li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li></ul><p><strong>v-pre指令</strong>：</p><ul><li>跳过其所在节点的编译过程。</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li></ul><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>定义语法：（指令名 + 配置对象或者回调函数）<br><code>new Vue(&#123;directives:&#123;指令名:配置对象&#125;&#125;)</code>或<code>new Vue(&#123;directives&#123;指令名:回调函数&#125;&#125;)</code></p><p><code>Vue.directive(指令名,配置对象) </code>或<code> Vue.directive(指令名,回调函数)</code></p><p>配置对象中常用的3个回调：(回调都有两个参数，分别是element和binding)</p><ul><li>bind：指令与元素成功绑定时调用。</li><li>inserted：指令所在元素被插入页面时调用。</li><li>update：指令所在模板结构被重新解析时调用。</li></ul><p>注意：</p><ul><li>指令定义时不加v-，但使用时要加v-；</li><li>指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。用短横线连接各个单词。</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><em>生命周期</em>，又称生命周期回调函数、生命周期函数、生命周期钩子，是Vue在关键时刻帮</p><p>我们调用的一些特殊名称的函数。生命周期函数的名字不可更改，但函数的具体内容是</p><p>程序员根据需求编写的。生命周期函数中的this指向是vm 或 组件实例对象。</p><h3 id="图解生命周期"><a href="#图解生命周期" class="headerlink" title="图解生命周期"></a>图解生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>常用的生命周期钩子：</p><ul><li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li><li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li></ul><p>关于销毁Vue实例：</p><ul><li>销毁后借助Vue开发者工具看不到任何信息。</li><li>销毁后自定义事件会失效，但原生DOM事件依然有效。</li><li>一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</li></ul><h2 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h2><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><p>Vue中使用组件的三大步骤：</p><ul><li>定义组件(创建组件)</li><li>注册组件</li><li>使用组件(写组件标签)</li></ul><p><em>如何定义一个组件？</em></p><p>使用<code>Vue.extend(options)</code>创建，其中options和<code>new Vue(options)</code>时传入的那个options</p><p>几乎一样，但也有点区别:</p><ul><li>el不要写，为什么？ —— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</li><li>data必须写成函数，为什么？ ——避免组件被复用时，数据存在引用关系。 引用关系修改值会发生连带效果</li></ul><p>说明：使用template可以配置组件结构。</p><p><em>如何注册组件？</em></p><ul><li>局部注册：靠new Vue的时候传入components选项</li><li>全局注册：靠<code>Vue.component(&#39;组件名&#39;,组件)</code></li></ul><p><em>使用组件</em>：<br>    <code>&lt;school&gt;&lt;/school&gt;</code></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><em>关于组件名:</em></p><ul><li><p>一个单词组成：</p><ul><li><p>第一种写法(首字母小写)：school</p></li><li><p>第二种写法(首字母大写)：School</p></li></ul></li><li><p>多个单词组成：</p><ul><li>第一种写法(kebab-case命名)：my-school</li><li>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</li></ul><p>​</p><p>注意：<br>(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。<br>(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p></li></ul><p><em>关于组件标签:</em><br>            第一种写法：<code>&lt;school&gt;&lt;/school&gt;</code><br>            第二种写法：<code>&lt;school/&gt; </code> 自闭和<br>            备注：不能使用脚手架时，<code>&lt;school/&gt;</code>会导致后续组件不能渲染。</p><p><em>定义组件简写</em></p><p>const school &#x3D; Vue.extend(options) 可简写为：const school &#x3D; options   Vue自动帮你调用Vue.extend方法</p><h3 id="组件可以嵌套使用"><a href="#组件可以嵌套使用" class="headerlink" title="组件可以嵌套使用"></a>组件可以嵌套使用</h3><p><code>&lt;container&gt;&lt;main&gt;&lt;/main&gt;&lt;/container&gt;</code></p><h3 id="Vue-Component"><a href="#Vue-Component" class="headerlink" title="Vue.Component"></a>Vue.Component</h3><p>组件本质是一个名为VueComponent的构造函数，使用组件会生成实例对象，是由Vue.extend生成的(是组件是构造函数，由方法生成)。</p><p>使用组件时只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，Vue解析时会帮我们创建组件的实例对象，（解析模板的时候创建实例对象），即Vue帮我们执行的：</p><p><code>new VueComponent(options)</code>操作。</p><p><strong>特别注意</strong>：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！（每</p><p>个组件都是全新的构造函数）即使使用的是同一个组件标签。</p><p><em>关于this指向：</em></p><ul><li>组件配置中：<br>data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</li><li>new Vue(options)配置中：<br>data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</li></ul><h3 id="重要的内置关系"><a href="#重要的内置关系" class="headerlink" title="重要的内置关系"></a>重要的内置关系</h3><p>一个重要的内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></p><p>作用：让组件实例对象可以访问到 Vue原型上的属性、方法。</p><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>在同一个文件当中编写HTML、CSS、JS，使其得到封装。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    //html代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//js代码</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    //css代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App.vue是最大的组件，管理所有的组件</p><p>main.js是创建vm实例的地方，引入最大的组件App</p><h2 id="脚手架Vue-CLI"><a href="#脚手架Vue-CLI" class="headerlink" title="脚手架Vue CLI"></a>脚手架Vue CLI</h2><p>介绍：Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统</p><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><p>创建项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>创建之后项目结构：</p><pre><code>├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol><li>vue.js与vue.runtime.xxx.js的区别：<ol><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:&#123;</span><br><span class="line"><span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line"><span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line"><span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;....&#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步使用混入：</p><p>​全局混入：<code>Vue.mixin(xxx)</code><br>​局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p>​该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p>​该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p>​该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于任意组件间通信。</p></li><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p>一种组件间通信的方式，适用于任意组件间通信。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去取消订阅。</p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>目前官方推荐使用 <a href="https://github.com/vuejs/create-vue"><code>create-vue</code></a> 来创建基于 <a href="https://cn.vitejs.dev/">Vite</a> 的新项目。</p></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了JS框架Vue的相关知识。</summary>
    
    
    
    <category term="Vue学习记录" scheme="http://ianblog.top/categories/Vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Vue" scheme="http://ianblog.top/tags/Vue/"/>
    
    <category term="框架" scheme="http://ianblog.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——类型声明文件</title>
    <link href="http://ianblog.top/posts/d4bec260.html"/>
    <id>http://ianblog.top/posts/d4bec260.html</id>
    <published>2023-06-27T06:31:28.000Z</published>
    <updated>2023-09-24T02:36:08.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript中有一类特殊文件——类型声明文件。</p><p>关于TypeScript的内容也可以<a href="https://ianlee5645.github.io/learn-typescript">戳</a>⬅️</p></blockquote><h1 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h1><p>我们知道TS代码文件的类型是<code>.ts</code>文件，实际开发中会出现另一种类型：<code>.d.ts</code>文件。</p><p>这是因为：在开发的过程中，不可避免要使用到第三方的JS库。</p><p>我们在使用第三方库的时候，会发现它们几乎都有相应的TS类型。</p><p>这是由于类型声明文件，给已存在的JS库提供了类型信息。</p><p>因此，在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>类型声明文件就是用来提供类型信息的文件，只包含类型信息，不包含可执行代码。编译时不会生成相应的<code>js</code>文件。作用是给JS提供类型信息。</p><p>所以JS库要能够提供类型信息，需要使用<code>.d.ts</code>文件。</p><h2 id="内置类型声明文件"><a href="#内置类型声明文件" class="headerlink" title="内置类型声明文件"></a>内置类型声明文件</h2><p>TS为JS运行时可用的所有标准化内置API都提供了声明文件。</p><p>例如，使用数组的<code>forEach</code>方法的时候：</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/file01.png"></p><p>会显示出对应类型声明文件，上面是<code>lib.es5.d.ts</code>。</p><h2 id="第三方库类型声明文件"><a href="#第三方库类型声明文件" class="headerlink" title="第三方库类型声明文件"></a>第三方库类型声明文件</h2><ol><li>有的第三方库自带有类型声明文件，例如<code>vue</code>：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/file02.png"></p><p>这种情况下，正常导入该库，TS 就会自动加载库自己的类型声明文件，以提供该      库的类型声明。</p><ol start="2"><li><p>如果第三方库中没有，可以下载对应的TS类型声明包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev @types/* // *表示库的名称</span><br><span class="line">// 例如：</span><br><span class="line">npm i --save-dev @types/react</span><br></pre></td></tr></table></figure><blockquote><p>具体可以查看<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/"><code>DefinitelyTyped</code></a>.</p></blockquote></li></ol><h3 id="自定义类型声明文件"><a href="#自定义类型声明文件" class="headerlink" title="自定义类型声明文件"></a>自定义类型声明文件</h3><p>当类型需要多个文件共享，可以使用模块机制（<code>import/export</code>）。</p><p>当需要给存在的变量声明类型，可以使用<code>declare</code>关键字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 type、interface 等这些明确就是 TS 类型的（只能在 TS 中使用的），可以省略 declare 关键字。</li><li>对于 let、function 等具有双重含义（在 JS、TS 中都能用），应该使用 declare 关键字，明确指定此处用于类型声明。</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的类型声明文件。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——进阶</title>
    <link href="http://ianblog.top/posts/4574082c.html"/>
    <id>http://ianblog.top/posts/4574082c.html</id>
    <published>2023-06-24T09:21:48.000Z</published>
    <updated>2023-09-24T02:35:31.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript中有许多高级特性。</p><p>关于TypeScript的内容也可以<a href="https://ianlee5645.github.io/learn-typescript">戳</a>⬅️</p></blockquote><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><p>TS中的高级类型有很多，例如：class类，交叉类型，泛型，索引签名类型，映射类型。</p><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TS是面向对象的JS，支持面向对象的全部特性，比如类、接口等。</p><p>TS全面支持ES2015中引入的class关键字，并为其添加了类型注解和其他语法。</p><p>TS中的类包含以下模块（类的数据成员）：</p><ul><li>字段：字段是类里面声明的变量。字段表示对象的有关数据。</li><li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li><li>方法：  方法为对象要执行的操作。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123; </span><br><span class="line">    <span class="comment">// 字段 </span></span><br><span class="line">    <span class="attr">engine</span>: <span class="built_in">string</span>;</span><br><span class="line">    wheels = <span class="number">4</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数 </span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">engine: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">engine</span> = engine </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    <span class="title function_">disp</span>(): <span class="built_in">void</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发动机为 : &quot;</span> + <span class="variable language_">this</span>.<span class="property">engine</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Engine 1&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/advanceType01.png"></p><p>说明：</p><ul><li>根据TS中类型推论，实例对象c的类型是Car。</li><li>TS中的class，不仅提供了class的语法功能，也作为一种类型存在。</li><li>方法的类型注解（参数和返回值）与函数用法相同。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>类实现继承有两种方式：</p><ol><li><p>extends（继承父类）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">miaow</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br></pre></td></tr></table></figure></li><li><p>implements（实现接口）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">  <span class="title function_">sing</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> <span class="keyword">implements</span> <span class="title class_">Singable</span> &#123;</span><br><span class="line">  <span class="title function_">sing</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;lalala&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口意味着类中要提供接口中指定的所有方法和属性。</p></li></ol><h3 id="类成员的访问控制修饰符"><a href="#类成员的访问控制修饰符" class="headerlink" title="类成员的访问控制修饰符"></a>类成员的访问控制修饰符</h3><p>TS中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。包括三类：</p><ul><li><p><strong>public</strong>:：表示公有的、公开的，公有成员可以被任何地方访问，默认可见性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>protected</strong>：表示受保护的，仅对其声明所在类和子类中（非实例对象）可见。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move&#x27;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">miaow</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">move</span>()  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>private</strong>：表示私有的，只在当前类中可见，对实例对象以及子类也是不可见的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encapsulate</span> &#123; </span><br><span class="line">   <span class="attr">str1</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span> </span><br><span class="line">   <span class="keyword">private</span> <span class="attr">str2</span>: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Encapsulate</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str1</span>)     <span class="comment">// 可访问 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str2</span>)   <span class="comment">// 编译错误， str2 是私有的</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/advanceType02.png"></p></li></ul><p>额外的修饰符：**<code>readonly</code>**</p><p>**<code>readonly</code>**：表示只读，用来防止在构造函数之外对属性进行赋值，只能用来修饰属性。</p><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>功能类似于接口继承，用于组合多个类型为一个类型（常用于接口），用&amp;实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Contact</span> &#123;<span class="attr">phone</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = <span class="title class_">Person</span> &amp; <span class="title class_">Contact</span></span><br><span class="line">le <span class="attr">obj</span>: <span class="title class_">PersonDetail</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">phone</span>: <span class="string">&#x27;1818181818&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonDetail</span> = &#123;<span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">phone</span>: <span class="built_in">string</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>交叉类型（&amp;）与接口继承（extends）都可以实现对象类型的组合。不同的是对于同名属性的合并处理：</p><p>接口继承（extends）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现错误：</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/advanceType03.png"></p><p>交叉类型（&amp;）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B</span><br></pre></td></tr></table></figure><p>不出现错误：</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/advanceType04.png"></p><p>可以理解为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>如果对于一个函数，我们的目的是传入什么数据就返回什么数据，也就是说参数和返回值的类型要一致。这样的话，很容易想到any：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;<span class="keyword">return</span> value&#125;</span><br></pre></td></tr></table></figure><p>但是使用any的话，会丢失TS的类型保护。所以需要借助泛型。</p><p>泛型能够在保证类型安全的前提下，让函数，接口等可以与多种类型一起工作，从而实现复用，常用于函数，接口，类中。</p><p>格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;<span class="keyword">return</span> value&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在函数名称后面添加&lt;&gt;，然后在其中写入类型变量。</li><li>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值。</li><li>类型变量相当于一个类型容器，能够捕获用户提供的类型。</li><li>Type可以是任意合法的变量名称。</li></ul><p>调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = fn&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> str = fn&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">// 简化调用</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">fn</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在函数名称后面添加&lt;&gt;，然后在其中指定类型，之后类型变量Type就能捕获到类型。</li><li>如果省略&lt;&gt;，TS内部能根据实参推断出Type的类型。</li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>因为类型变量Type可以代表多个类型，这会导致意想不到的错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>&gt;(<span class="attr">value</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/advanceType05.png"></p><p>我们知道原始类型的数据是没有length属性的。</p><p>解决：给泛型添加约束，收缩类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.指定具体类型</span><br><span class="line">function fn&lt;Type&gt;(value: Type[]): Type[] &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br><span class="line">// 2.继承接口</span><br><span class="line">interface ILength &#123;length: number&#125;</span><br><span class="line">function fn&lt;Type extends ILength&gt;(value: Type): Type &#123;</span><br><span class="line">  console.log(value.length)</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：泛型的类型变量可以有多个，并且类型变量之间可以约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="title function_">fn</span>(person, <span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><p><code>keyof</code>是个关键字，接收对象类型，生成键名的联合类型。本例为：<code>&quot;name&quot; | &quot;age&quot;</code>。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口可以配合泛型来使用，增强灵活性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdFunc</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> <span class="title class_">Type</span></span><br><span class="line">  <span class="attr">ids</span>: <span class="function">() =&gt;</span> <span class="title class_">Type</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">IdFunc</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">id</span>(<span class="params">value</span>) &#123;<span class="keyword">return</span> value&#125;,</span><br><span class="line">  <span class="title function_">ids</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类也能配合泛型来使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Type</span></span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: Type, y: Type</span>) =&gt;</span> <span class="title class_">Type</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myCal = <span class="keyword">new</span> <span class="title class_">Cal</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myCal.<span class="property">value</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="索引签名类型"><a href="#索引签名类型" class="headerlink" title="索引签名类型"></a>索引签名类型</h2><p>在定义接口的时候，我们可以很明确地指定对象的结构，但是有时候无法确定对象中会出现哪些属性（或者对象中可以出现任意属性），这时需要借助索引标签类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>上面的接口约束了对象的键只能是字符串类型，值是数值类型。</li><li>通过这种方式，只要满足要求，对象中 可以出现任意多的属性。</li><li><code>key</code>只是占位符，可以是任意合法的变量名称。</li></ul><h2 id="索引查询类型"><a href="#索引查询类型" class="headerlink" title="索引查询类型"></a>索引查询类型</h2><p>可以查询属性的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span> = &#123;<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">string</span>, <span class="attr">c</span>: <span class="built_in">boolean</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span>]  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span>]  <span class="comment">// number | string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = <span class="title class_">Props</span>[keyof <span class="title class_">Props</span>]  <span class="comment">// number | string | boolean</span></span><br></pre></td></tr></table></figure><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>基于旧类型创建出新类型（对象类型），减少重复：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>, <span class="attr">z</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="comment">// 映射类型写法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PropKeys</span> = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeA</span> = &#123;[k <span class="keyword">in</span> <span class="title class_">PropKeys</span>]: <span class="built_in">number</span>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>k in PropKeys</code>表示 <code>k </code>可以是 <code>PropKeys</code> 联合类型中的任意一个。</li><li><strong>映射类型只能在类型别名中使用，不能在接口中使用</strong></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的高级类型。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——基础</title>
    <link href="http://ianblog.top/posts/eb05c984.html"/>
    <id>http://ianblog.top/posts/eb05c984.html</id>
    <published>2023-06-20T13:18:28.000Z</published>
    <updated>2023-09-24T02:33:52.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript最大的特点就是给JavaScript加上了类型。</p><p>关于TypeScript的内容还可以访问：<a href="https://ianlee5645.github.io/learn-typescript">这里</a></p></blockquote><h1 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h1><p>TS中添加了类型注释，如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>其中的<code>: number</code>就是类型注释</p><p>作用：给变量添加类型约束。上述代码就是给<strong>age</strong>变量添加了<strong>number</strong>数值类型的约束。如果之后进行了下面的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="string">&#x27;18&#x27;</span></span><br></pre></td></tr></table></figure><p>代码编辑器就会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/baseType01.png"></p><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>TS中的类型有一部分是JS当中就存在的，有一部分是新增的。</p><ol><li>原本就有<ul><li>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol</li><li>对象类型：object</li></ul></li><li>新增：联合类型、自定义类型、接口、元组、字面量、枚举、void、any等</li></ol><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>双精度的64位浮点数，可以表示多种进制的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">binary</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octal</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;    <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dec</span>: <span class="built_in">number</span> = <span class="number">6</span>;    <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hex</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;    <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>同样支持单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>、反引号<code>`` </code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="built_in">string</span> = <span class="string">&#x27;man&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">words</span>: <span class="built_in">string</span> = <span class="string">`hello`</span>;</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><p>null表示空对象的引用，是一个只有一个值的特殊类型。</p><p>undefined是用于初始化一个未设置值的变量。</p><p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 编译错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><h2 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">symbol</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>使用数组类型可以限制数组中元素的类型。具体有两种基本的写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素类型后面加上[]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 使用数组泛型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strings</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素既有数值又有字符</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>];</span><br></pre></td></tr></table></figure><p>上述写法更推荐使用**number[]**。</p><p>其中<code>|</code>在TS中叫做<strong>联合类型</strong>，是指由两个或多个其他类型组成的类型，表似可以是其中的任意一种。（后面会讲）</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数类型实际上指的是：函数参数和返回值的类型。有两种指定方式：</p><ol><li><p>分别指定参数、返回值的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时指定参数、返回值的类型（只适用于函数表达式+箭头函数的形式）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>函数参数的传递：JS中如果传递的实参<strong>少于</strong>或<strong>多于</strong>形参时，是不会报错的；但是TS会显示错误。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/baseType02.png"></p><p>TS中可选参数：在可传可不传的参数名称后面添加?</p><p>这样就能解决上述问题了：</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/baseType03.png"></p><p>不过要注意的是：可选参数只能出现在参数列表的最后，也就是说可选参数的后面不能出现必选参数。</p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>TS中的对象类型是在描述对象的结构（有什么类型属性和方法）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="title function_">speak</span>(): <span class="built_in">void</span>&#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果方法带有参数的话，类似函数参数，写成：<code>speak(words: string): void</code>即可。</li><li>在一行指定对象类型时，各个属性之间用<code>,</code>或<code>;</code>分隔。</li><li>如果通过换行指定对象类型时，可以省略各个属性之间的分隔符。</li><li>同样，如果某个属性也是可选的，使用?即可。</li></ul><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）可以通过管道<code>|</code>将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p><p>格式：<code>Type1 | Type2 | Type3</code></p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">val</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">12</span></span><br><span class="line">val = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">disp</span>(<span class="params">name: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>也称类型别名，为任意类型起别名。</p><p>当同一类型（复杂）被多次使用时，可以通过类型别名，<strong>简化</strong>该类型的使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CustomArray</span> = (<span class="built_in">number</span> | <span class="built_in">string</span>)[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">CustomArray</span> = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>自定义类型使用type关键字创建。</li><li>类型别名可以是任意合法的变量名。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现。</p><p>当一个对象类型被多次使用，最好使用接口来描述，以达到复用的目的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">speak</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>接口使用interface创建。</li><li>接口名可以是任意合法的变量名。</li><li>接口不能编译成对应的JS代码，他只是TS的一部分。</li><li>接口与类型别名的区别：<ul><li>接口只能为对象指定类型。</li><li>类型别名可以为任意类型指定别名。</li></ul></li></ul><p>当两个接口之间有共同的属性或方法，可以使用<strong>继承</strong>实现复用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;<span class="attr">weight</span>: <span class="built_in">string</span>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>使用extends关键字实现了Cat继承Animal。</li><li>继承之后，Cat也拥有了Animal的属性和方法。</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组是另一种类型的数组，它确切地知道包含多少个元素，以及特定索引对应的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">position</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39</span>, <span class="number">116</span>]</span><br></pre></td></tr></table></figure><p>应用场景：利用经纬度存储位置信息。</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>用于指定某个变量为某个值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="number">18</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure><p>对比：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;Hello TS&#x27;</span></span><br></pre></td></tr></table></figure><p>结果：</p><ol><li>变量str1的类型为：string</li><li>常量str2的类型为：’Hello TS’</li></ol><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举定义了一组命名常量，描述一个值，该值是命名常量中的一个。</p><p>枚举的功能类似字面量类型+联合类型，表示一组可选值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;<span class="title class_">Sunday</span>, <span class="title class_">Monday</span>, <span class="title class_">Tuesday</span>, <span class="title class_">Wednesday</span>, <span class="title class_">Thursday</span>, <span class="title class_">Friday</span>, <span class="title class_">Saturday</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Day</span>.<span class="property">Sunday</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>枚举使用enum关键字创建。</p></li><li><p>约定枚举名称和值以大写字母开头，值用<code>,</code>分隔。</p></li><li><p>访问枚举成员，类似JS对象中的点语法。</p></li><li><p>枚举的值默认是从0开始自增的数值，这时称为数值枚举。</p></li><li><p>枚举的值还可以是字符串，每个成员都必须有初始值，这时称为字符串枚举。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类型会编译为JS代码，因为枚举不仅作为类型，还提供值。可以使用常量枚举，避免编译时创建该对象。<code>const enum ...</code></p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/baseType04.png"></p></li></ul><p>一般情况下，推荐使用字面量类型+联合类型的方式，因为更直观、简洁、高效。</p><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>用于标识返回值的类型，标识方法没有返回值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>声明为any的变量可以赋予任意类型的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">&#x27;I an who I am&#x27;</span>;</span><br><span class="line">x = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>不推荐使用any，因为相当于不使用TS的类型特性。</li><li>上面代码显示声明了any类型，隐式声明的情况：<ul><li>声明变量不提供类型也不提供默认值</li><li>函数参数不声明类型</li></ul></li></ul><h2 id="类型的判断"><a href="#类型的判断" class="headerlink" title="类型的判断"></a>类型的判断</h2><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>TS中带有类型推论机制，可以在没有明确给出类型的情况下推断出类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;<span class="keyword">return</span> a + b&#125;</span><br></pre></td></tr></table></figure><p>这两种情况下，类型注解可以不写。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><ol><li><pre><code class="typescript">let someValue: number | string = &quot;this is a string&quot;let strLength: number = (someValue as string).length;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```typescript</span><br><span class="line">   let someValue: number | string = &quot;this is a string&quot;</span><br><span class="line">   let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>应用场景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://...&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linkDOM = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;link&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLAnchorElement</span></span><br></pre></td></tr></table></figure><p>说明：<br><code>getElementById</code> 方法返回值的类型是 <code>HTMLElement</code>，该类型只包含所有标签公共的属性或方法，不包含<code>a</code> 标签特有的 <code>href</code> 等属性。如果后续访问<code>href</code>属性，就会报错，通过类型断言使<code>linkDOM</code>的类型更具体。</p>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的类型注释和基础类型。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript——介绍</title>
    <link href="http://ianblog.top/posts/92138a47.html"/>
    <id>http://ianblog.top/posts/92138a47.html</id>
    <published>2023-06-17T05:21:23.000Z</published>
    <updated>2023-09-24T02:32:14.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript为JavaScript带来了类型的概念。</p><p>关于TypeScript的内容，你可以访问<a href="https://ianlee5645.github.io/learn-typescript">戳我</a>。</p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript?"></a>什么是TypeScript?</h2><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/logo.jpg"></p><p>TypeScript（简称：TS）是JavaScript的超集，支持ES6语法。</p><p>TypeScript &#x3D; Type + JavaScript（引入了类型的概念）</p><p>TypeScript是微软开发的开源编程语言，能够编译成JavaScript。</p><p>下面是一个最基本的实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age, hello)</span><br></pre></td></tr></table></figure><h2 id="新增语言特性"><a href="#新增语言特性" class="headerlink" title="新增语言特性"></a>新增语言特性</h2><p>TypeScript相较于JavaScript新增了一些新的语言扩展，包括：</p><ul><li>类型</li><li>接口</li><li>枚举</li><li>元组</li><li>Mixin</li><li>…</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>TypeScript属于静态类型的编程语言，编译期做类型检查；而JavaScript属于动态类型的编程语言，执行期做类型检查。</p><p>TypeScript能够更早发现代码中存在的错误，节约修复代码的时间，提高效率。</p><p>完善的代码提示，提升开发体验。</p><p>兼容JavaScript，上手简单易用。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/ts-js.png"></p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>安装命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><p>typescript包：用来编译TS代码的包，提供了tsc命令。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/ts-to-js.png"></p><p>检查是否安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure><p>使用：</p><p>创建一个hello.ts文件，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>此时在同级目录下会生成一个同名的JS文件。</p><p>执行JS代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure><p>扩展：</p><p>tsc能够同时编译多个ts文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure><p>tsc常用的编译参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–module</td><td>载入扩展模块</td></tr><tr><td>–target</td><td>设置ECMA版本</td></tr><tr><td>–removeComments</td><td>删除文件的注释</td></tr><tr><td>–out</td><td>编译多个文件并合并到一个输出的文件</td></tr><tr><td>–watch</td><td>在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译</td></tr></tbody></table><h2 id="简化步骤"><a href="#简化步骤" class="headerlink" title="简化步骤"></a>简化步骤</h2><p>可以使用ts-node包简化步骤，这样就不需要每次先编译然后再执行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br><span class="line">ts-node hello.ts</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的path模块。</summary>
    
    
    
    <category term="TypeScript学习记录" scheme="http://ianblog.top/categories/TypeScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="TypeScript" scheme="http://ianblog.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>实现中国梦，青年勇担当</title>
    <link href="http://ianblog.top/posts/dc3e95fb.html"/>
    <id>http://ianblog.top/posts/dc3e95fb.html</id>
    <published>2023-06-11T09:32:52.000Z</published>
    <updated>2023-10-05T06:24:41.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现中国梦，青年勇担当"><a href="#实现中国梦，青年勇担当" class="headerlink" title="实现中国梦，青年勇担当"></a>实现中国梦，青年勇担当</h2><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/zhongguomeng.jpg"></p><p>习近平总书记有言，“实现中国梦，需要依靠青年，也能成就青年。”青年一代有理想、有担当，国家就有前途，民族就有希望，实现中华民族伟大复兴就有源源不断的强大力量。站在新的时代节点上，面对百年未有之大变局，中国青年应当肩负起实现中华民族伟大复兴的中国梦，不懈奋斗，勇于担当。</p><p>实现中国梦，青年须挺身而出，肩负使命，方有破阻之冀。</p><p>遥记当时，庚子鼠年，如期而至。然而荆楚大地，不闻鞭炮阵阵，却见战鼓频摧！新冠疫情来势汹汹，举国“既过年过，也过难关”。无数的青年工作者奔赴一线，不惧死亡，无私奉献。白衣天使们奋勇拼搏，最美“逆行者”迎难而上。“千灯共燃曜南北，众志成城克时艰”。抗击新冠肺炎的严峻斗争，让众多应届毕业生以及高考生经受了磨难，也收获了成长，切身体会到了“志不求易者成，事不避难者进”的道理。习总书记说：“山再高，往上攀，总能登顶；路再长，走下去，定能到达。”疫情是一场悲剧，更是一场空前的团聚。中华民族团结一致，心向一处，共克时艰。新时代青年应像他们一样挺身而出，肩负使命，努力在劈波斩浪中开拓前进。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/yiqing.jpg"></p><p>实现中国梦，青年须勤劳肯干，踏实刻苦，方有成事之力。</p><p>在脱贫攻坚的战场上，许多90后干部披星戴月，把爱和希望的种子埋在广大贫困群众心中；在凉山森林火灾中，24位90后，两位00后消防战士勇于逆行，用生命诠释了烈火青春；在西部教育建设中，怀着执着的理想的毕业生群体，奔赴条件艰苦的西部和边疆地区，十几年如一日，扎根基层教书育人，写下了充满激情和奋斗的人生历程。“同人民一道拼搏，同祖国一道前进，服务人民，奉献祖国，是当代中国青年的正确方向。”习总书记如是说。越来越多的青年选择去往基层和人民中去建功立业，青春之花绽放于祖国最需要的地方。新时代青年也应当如他们般勤劳肯干，踏实刻苦，内心奔涌着家国情怀。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/jiaguoqinghuai.jpg"></p><p>实现中国梦，青年须拓宽视野，坚定信念，方有筑梦之基。</p><p>青春者，人生之王，人生之春，人生之华也。毛泽东说过，“青年人好像早晨八九点的太阳，希望寄托在你们身上。”广大的海外学子作为国家发展，民族复兴的坚实力量，更应主动承担起振兴中华的责任。如钱学森先生般，面对美国诱惑，宠辱不惊，学成归国，投入祖国建设大页中去，终是“五轮春秋漫归途，十载风雨两弹成”。亦如杨振宁先生般，怀揣火热赤子之心，将一生献给科学，推动祖国的发展，做到“功在世界，心怀国家”。新时代青年也应像他们般拓宽视野，坚定信念，勇敢逐梦报效祖国。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/qingnian.jpg"></p><p>时代浪潮涌动，弄潮儿驾驶“青春号”扬帆启航！看，新时代青年正迈着坚定的步伐稳步向前；听，新时代青年正高呼 “振兴中华，吾辈当先”的誓言。新时代青年正以青春书写责任，担当青年使命，在新的时代绘卷上描绘浓墨重彩的一笔，在中国之伟大复兴的中国梦中激扬青春力量！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现中国梦，青年勇担当&quot;&gt;&lt;a href=&quot;#实现中国梦，青年勇担当&quot; class=&quot;headerlink&quot; title=&quot;实现中国梦，青年勇担当&quot;&gt;&lt;/a&gt;实现中国梦，青年勇担当&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net</summary>
      
    
    
    
    <category term="杂集（🤹‍）" scheme="http://ianblog.top/categories/%E6%9D%82%E9%9B%86%EF%BC%88%F0%9F%A4%B9%E2%80%8D%EF%BC%89/"/>
    
    
    <category term="notes" scheme="http://ianblog.top/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——队列</title>
    <link href="http://ianblog.top/posts/63bb1f4.html"/>
    <id>http://ianblog.top/posts/63bb1f4.html</id>
    <published>2023-06-05T03:21:01.000Z</published>
    <updated>2023-09-22T13:09:24.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>队列是一种<strong>先进先出</strong>的数据结构。</p></blockquote><h2 id="队列是什么？"><a href="#队列是什么？" class="headerlink" title="队列是什么？"></a>队列是什么？</h2><p>对列遵循<strong>先进先出（FIFO）</strong>，在队列尾部添加元素，在顶部移除元素。</p><p>队列在日常生活中是很常见的，比如买票排队。</p><h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><p>由于队列是从顶部移除元素，所以不仅需要获取队列尾部，还需要定义变量记录队列顶部位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;; <span class="comment">// 队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>; <span class="comment">// 追踪最后元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>; <span class="comment">// 追踪第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些方法了：最基础的就是添加与删除了</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>enqueue</code>(element)</td><td>添加元素</td></tr><tr><td><code>dequeue()</code></td><td>删除第一项元素并返回</td></tr><tr><td><code>front()</code></td><td>返回队列第一项元素</td></tr><tr><td><code>isEmpty()</code></td><td>检查队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回队列长度</td></tr><tr><td><code>clear()</code></td><td>清空队列</td></tr><tr><td><code>toString()</code></td><td>以字符串的方式打印队列</td></tr></tbody></table><h3 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h3><p>以<code>lastPos</code>作为键，将元素添加进队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">lastPos</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h3><p>首先取得首个元素，然后将其删除，要注意的是，删除首个元素之后，它的下一个元素就成了首个元素了，所以需要将<code>firstPos</code>的值更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span>++; <span class="comment">// 自增，首个元素的索引后移</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-第一项元素"><a href="#3-第一项元素" class="headerlink" title="3. 第一项元素"></a>3. 第一项元素</h3><p><code>firstPos</code>用来追踪第一项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-队列是否为空"><a href="#4-队列是否为空" class="headerlink" title="4. 队列是否为空"></a>4. 队列是否为空</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span> === <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 或者为了复用方法</span></span><br><span class="line">  <span class="comment">// return this.size() === 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列长度"><a href="#5-队列长度" class="headerlink" title="5. 队列长度"></a>5. 队列长度</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastPos</span> - <span class="variable language_">this</span>.<span class="property">firstPos</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-清空队列"><a href="#6-清空队列" class="headerlink" title="6. 清空队列"></a>6. 清空队列</h3><p>重置队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-打印队列"><a href="#7-打印队列" class="headerlink" title="7. 打印队列"></a>7. 打印队列</h3><p>将队列中的元素以字符串的形式打印出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="variable language_">this</span>.firstPos]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">firstPos</span> + <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">lastPos</span>; i++) &#123;</span><br><span class="line">    str += <span class="string">`,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;ian&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;ian,jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;ian&#x27;</span></span><br><span class="line">queue.<span class="title function_">dequeue</span>(); <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">toString</span>()); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>上面我们创建出了一个队列，实现了从队列尾部添加元素，顶部移除元素。如果我们还想要实现从队列尾部删除元素，从顶部添加元素呢？这就需要借助双端队列了。</p><p><strong>双端队列</strong>是一种允许我们同时从队列顶部和尾部添加和移除元素的特殊队列。有了这样的结构，双端队列既能实现<strong>先进先出</strong>又能实现<strong>后进先出</strong>，所以可以将其看作队列和栈相结合的一种数据结构。</p><h3 id="创建双端队列"><a href="#创建双端队列" class="headerlink" title="创建双端队列"></a>创建双端队列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span> &#123;</span><br><span class="line">  constructor &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于双端队列非常类似于队列与栈的结合，所以其方法也是类似的，这里就不再累述了。唯一不同的就是，双端队列还需要实现从顶部添加元素的方法。</p><h4 id="顶部添加元素"><a href="#顶部添加元素" class="headerlink" title="顶部添加元素"></a>顶部添加元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addFront</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 若为空，则直接添加</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">enqueue</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">firstPos</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 若顶部有空位则添加至空位</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span>--;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">firstPos</span>] = element;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若顶部无空位，则将元素整体往后推一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">lastPos</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>[i] = <span class="variable language_">this</span>.<span class="property">items</span>[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastPos</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstPos</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>] = element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用队列解决问题"><a href="#利用队列解决问题" class="headerlink" title="利用队列解决问题"></a>利用队列解决问题</h2><h3 id="1-击鼓传花"><a href="#1-击鼓传花" class="headerlink" title="1. 击鼓传花"></a>1. 击鼓传花</h3><p>问题描述：一群孩子围成一个圈，把花传递给傍边的人，一定时间后，花落在谁手上，谁就被淘汰，最终剩下的孩子为胜者。</p><p>问题思路：采用<strong>循环队列</strong>的方式，将所有孩子添加进队列，依次将顶部孩子移除再添加进尾部（传花之后，当前孩子就变成了最末尾的了）。每次循环淘汰一名孩子，最后剩下一名。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> element: Array 待添加的元素列表</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@params</span> num: Number 传花的次数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">elements, num</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> elimitates = []; <span class="comment">// 淘汰列表</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(element[i]); <span class="comment">// 循环添加元素</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 当剩下一个以上时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 出队再入队 -- 循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    elimitates.<span class="title function_">push</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// 传完花之后，当前拿到花的淘汰</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    elimitates,</span><br><span class="line">    <span class="attr">winner</span>: queue.<span class="title function_">dequeue</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;ian&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;kate&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">hotPotato</span>(names, <span class="number">4</span>); <span class="comment">// &#x27;ian&#x27; is the winner</span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>首先添加元素：’ian’ — ‘jack’ — ‘kate’；</li><li>然后传花：<del>‘jack’</del> —‘kate’ — ‘ian’；</li><li>再次传花：<del>‘kate’</del> — ‘ian’；</li><li>剩下：’ian’</li></ol><h3 id="2-回文检查"><a href="#2-回文检查" class="headerlink" title="2. 回文检查"></a>2. 回文检查</h3><p>回文是正反都能读通的单词、词语或者字符串。最简单检验一个值是否是回文结构的方式就是将字符串翻转（<code>reverse</code>），然后再比较前后是否一致。</p><p>实现思路：在上面我们实现了双端队列，能够在两端移除元素，非常适合用于判断一个字符串是否为回文数。只需要循环移除两端元素并且判断是否相等即可。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&quot;string&quot;</span>) &#123; <span class="comment">// 不是字符串则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> <span class="title class_">Deque</span>(); <span class="comment">// 队列</span></span><br><span class="line">  <span class="keyword">const</span> string = <span class="title function_">str</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 移除空格</span></span><br><span class="line">  <span class="keyword">let</span> firstChar; <span class="comment">// 首个字符</span></span><br><span class="line">  <span class="keyword">let</span> lastChar; <span class="comment">// 末尾字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    deque.<span class="title function_">enqueue</span>(string.<span class="title function_">charAt</span>(i)); <span class="comment">// 循环添加</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (deque.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123; <span class="comment">// 有可能遇到字符数为奇数的情况，所以只需最后的size为0或者1就行</span></span><br><span class="line">    firstChar = deque.<span class="title function_">dequeue</span>(); <span class="comment">// 移除首个字符</span></span><br><span class="line">    lastChar = deque.<span class="title function_">pop</span>(); <span class="comment">// 移除末尾字符</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isPalindrome</span>(<span class="string">&#x27;yakiooikay&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——队列</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构——栈</title>
    <link href="http://ianblog.top/posts/93fd0851.html"/>
    <id>http://ianblog.top/posts/93fd0851.html</id>
    <published>2023-06-02T01:21:01.000Z</published>
    <updated>2023-09-22T13:09:07.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈是一种<strong>后进先出</strong>的数据结构，具有广泛的应用。</p></blockquote><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈遵循后进先出（LIFO）原则。新添加的元素保存在栈顶，待删除的元素也是从栈顶开始删除；在栈的另一端就叫栈底。</p><p>栈非常适合用于保存浏览器的历史记录，新产生的记录压入栈顶，显示新页面，等到点击回退按钮之后，就将当前栈顶的记录弹出，重新显示上一次的页面。</p><h2 id="创建一个栈"><a href="#创建一个栈" class="headerlink" title="创建一个栈"></a>创建一个栈</h2><p>栈需要满足保存一系列元素，并且轻松实现添加以及删除元素，这让我们很容易想到<strong>数组</strong>。因为数组本身具备操作元素的方法，例如<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code>等等。事实上，利用对象也是能够实现的，继续往下看 😀。</p><h3 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = []; <span class="comment">// 用于保存元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要思考：栈需要实现什么样的方法？</p><p>当然，最基本的添加与删除是毋庸置疑的。除此之外，还应当实现方法来方便获取栈顶元素，元素个数，以及重置栈。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>push(element)</code></td><td>添加一个或者几个元素到栈顶</td></tr><tr><td><code>pop()</code></td><td>移除并返回栈顶元素</td></tr><tr><td><code>peek()</code></td><td>返回栈顶的元素（并不移除）</td></tr><tr><td><code>isEmpty()</code></td><td>检查栈是否为空</td></tr><tr><td><code>clear()</code></td><td>清空栈</td></tr><tr><td><code>size()</code></td><td>返回栈中元素个数</td></tr><tr><td><code>toString()</code></td><td>以字符串形式打印出所有元素</td></tr></tbody></table><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>利用数组的<code>push</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>利用数组的<code>pop</code>方法很容易实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-查看栈顶元素"><a href="#3-查看栈顶元素" class="headerlink" title="3. 查看栈顶元素"></a>3. 查看栈顶元素</h4><p>相当于是获取数组中最后一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-检查栈是否为空"><a href="#4-检查栈是否为空" class="headerlink" title="4. 检查栈是否为空"></a>4. 检查栈是否为空</h4><p><code>length</code>属性反映了数组元素的个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈"><a href="#5-清空栈" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>这里简单粗暴，直接将空数组赋值给了<code>items</code>，也可以循环调用<code>pop</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数"><a href="#6-元素个数" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素"><a href="#7-打印元素" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>直接使用数组身上的<code>toString</code>方法（将元素以逗号分隔的字符串形式返回）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// true</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// 添加元素2</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// 添加元素5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">isEmpty</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">toString</span>()); <span class="comment">// &quot;2,5&quot;</span></span><br><span class="line">stack.<span class="title function_">pop</span>(); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h3><p>首先创建一个栈类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>() &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>; <span class="comment">// 记录栈的大小</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的是，这里我们借助了<code>count</code>来记录栈的大小，因为对象不像数组拥有<code>length</code>属性。</p><h4 id="1-添加元素-1"><a href="#1-添加元素-1" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h4><p>直接使用<code>count</code>作为键名，<code>element</code>作为键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>] = element;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>++; <span class="comment">// 自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-删除元素-1"><a href="#2-删除元素-1" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h4><p>首先需要检查栈是否为空，若为空，则返回 undefined。对象删除元素，需要手动修改 count 的值，并且删除之前先将其保存以便返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span>--; <span class="comment">// 递减</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-检查栈是否为空"><a href="#3-检查栈是否为空" class="headerlink" title="3. 检查栈是否为空"></a>3. 检查栈是否为空</h4><p>直接判断<code>count</code>的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查看栈顶元素"><a href="#4-查看栈顶元素" class="headerlink" title="4. 查看栈顶元素"></a>4. 查看栈顶元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">count</span> - <span class="number">1</span>]; <span class="comment">// 栈顶元素是最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-清空栈-1"><a href="#5-清空栈-1" class="headerlink" title="5. 清空栈"></a>5. 清空栈</h4><p>将栈的状态重置为最初状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-元素个数-1"><a href="#6-元素个数-1" class="headerlink" title="6. 元素个数"></a>6. 元素个数</h4><p>只需要简单返回count的值就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打印元素-1"><a href="#7-打印元素-1" class="headerlink" title="7. 打印元素"></a>7. 打印元素</h4><p>数组版本中，数组实例身上有<code>toString()</code>方法，该方法可以将元素转换成以逗号分隔的字符串形式。但是对象需要我们手动实现一个方法打印其所有元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 若为空，则返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.items[i]&#125;</span>`</span>; <span class="comment">// 动态拼接字符串即可</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的使用"><a href="#栈的使用" class="headerlink" title="栈的使用"></a>栈的使用</h2><h3 id="1-十进制转换"><a href="#1-十进制转换" class="headerlink" title="1. 十进制转换"></a>1. 十进制转换</h3><p>十进制转换为其他的进制，相信大家都很熟悉：将十进制数除以要转换的进制数，对商取整，直到结果为0，然后将每次计算的余数拼接就得到了对应的进制数（要特别注意的是有的数需要转成字母）。</p><p>看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dgts = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>; <span class="comment">// 进制数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">decNumber, base</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = decNumber;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> rem = <span class="number">0</span>; <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>; <span class="comment">// 待拼接的字符串</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(!(base &gt;= <span class="number">2</span> &amp;&amp; base &lt;= <span class="number">36</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 边界情况，不能实现转换，返回空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number % base); <span class="comment">// 取余</span></span><br><span class="line">    stack.<span class="title function_">push</span>(rem); <span class="comment">// 添加余数</span></span><br><span class="line">    number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number / base); <span class="comment">// 更新number的值</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    str += dgts[stack.<span class="title function_">pop</span>()]; <span class="comment">// 拼接余数，从栈顶开始并且要做转换</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> str; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">// 1010</span></span><br><span class="line"><span class="title function_">convert</span>(<span class="number">1021</span>, <span class="number">16</span>); <span class="comment">//3fd</span></span><br></pre></td></tr></table></figure><h3 id="2-平衡括号"><a href="#2-平衡括号" class="headerlink" title="2. 平衡括号"></a>2. 平衡括号</h3><p>每个左括号都必须要有对应的右括号，才算平衡，例如<code>((&#123;&#125;)&#123;&#125;([])())</code>。不平衡的如<code>(()</code>、<code>&#123;[)&#125;</code>等。基本的思路是，将左括号压入栈中，每次遇到右括号，就进行判断，看当前栈顶的括号是否与右括号对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> left = <span class="string">&#x27;([&#123;&#x27;</span>; <span class="comment">// 左括号</span></span><br><span class="line"><span class="keyword">const</span> right = <span class="string">&#x27;)]&#125;&#x27;</span>; <span class="comment">// 右括号</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">parenthesesChecker</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>(); <span class="comment">// 栈</span></span><br><span class="line">  <span class="keyword">let</span> balanced = <span class="literal">true</span>; <span class="comment">// 是否平衡</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 循环变量</span></span><br><span class="line">  <span class="keyword">let</span> symbol; <span class="comment">// 字符</span></span><br><span class="line">  <span class="keyword">let</span> top; <span class="comment">// 栈顶字符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; symbols.<span class="property">length</span> &amp;&amp; balanced) &#123;</span><br><span class="line">    symbol = symbols[i]; <span class="comment">// 对应索引的字符</span></span><br><span class="line">    <span class="keyword">if</span> (left.<span class="title function_">indexOf</span>(symbol) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(symbol); <span class="comment">// 压入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.<span class="title function_">isEmpty</span>()) &#123; <span class="comment">// 遇到右括号但是栈为空</span></span><br><span class="line">      balanced = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      top = stack.<span class="title function_">pop</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">      <span class="keyword">if</span> (!(left.<span class="title function_">indexOf</span>(top) === right.<span class="title function_">indexOf</span>(symbol))) &#123; <span class="comment">// 左右括号比较</span></span><br><span class="line">        balanced = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> balanced &amp;&amp; stack.<span class="title function_">isEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了常见的数据结构——栈</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://ianblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="数据结构" scheme="http://ianblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>有关bo🐖</title>
    <link href="http://ianblog.top/posts/29dd20d4.html"/>
    <id>http://ianblog.top/posts/29dd20d4.html</id>
    <published>2023-05-20T05:14:00.000Z</published>
    <updated>2023-10-05T09:11:59.575Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Hello</strong>，我是<strong>Ian</strong>！</p><p>目前还是大四生。</p><p>喜欢ting音乐。</p><p>❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌<strong>（内容加载中。。。）</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">蓦然听到音乐的韵律，</span><br><span class="line">如泉水流淌在心间。</span><br><span class="line">旋律迂回荡漾空中，</span><br><span class="line">扣动灵魂的琴弦。</span><br><span class="line">它如风吹过山野，</span><br><span class="line">草木摇曳跳跃雪花。</span><br><span class="line">音符间舞动的色彩，</span><br><span class="line">绚烂绽放在四季。</span><br><span class="line">音乐是灵感的泉源，</span><br><span class="line">诗人深陷其中迷醉。</span><br><span class="line">它传递情感的沟通，</span><br><span class="line">在心弦上织梦纷飞。</span><br><span class="line">演奏者指尖行云流水，</span><br><span class="line">每一次弹奏都动人心怀。</span><br><span class="line">听众沉浸在旋律的漩涡，</span><br><span class="line">情绪起伏随音符跳跃。</span><br><span class="line">音乐不分国界与年纪，</span><br><span class="line">跨越语言表达情意。</span><br><span class="line">它抚慰疲惫的心灵，</span><br><span class="line">唤醒梦想在寂静里。</span><br><span class="line">愿音乐永远伴随心灵，</span><br><span class="line">奏响和谐的和弦。</span><br><span class="line">让我们跳动在音符的舞蹈，</span><br><span class="line">享受生命中的每个旋律。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Hello&lt;/strong&gt;，我是&lt;strong&gt;Ian&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;目前还是大四生。&lt;/p&gt;
&lt;p&gt;喜欢ting音乐。&lt;/p&gt;
&lt;p&gt;❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌&lt;strong&gt;（内容加载中。。。）&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="随心记（水星记）" scheme="http://ianblog.top/categories/%E9%9A%8F%E5%BF%83%E8%AE%B0%EF%BC%88%E6%B0%B4%E6%98%9F%E8%AE%B0%EF%BC%89/"/>
    
    
    <category term="notes" scheme="http://ianblog.top/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——http模块</title>
    <link href="http://ianblog.top/posts/4d927413.html"/>
    <id>http://ianblog.top/posts/4d927413.html</id>
    <published>2023-05-18T03:24:22.000Z</published>
    <updated>2023-09-24T11:22:17.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>中的<code>http</code>模块可用于搭建服务。</p></blockquote><h2 id="http模块介绍"><a href="#http模块介绍" class="headerlink" title="http模块介绍"></a><code>http</code>模块介绍</h2><p><code>http</code>模块是<code>Node.js</code>中的内置模块，是其网络的关键模块，允许<code>Node.js</code>通过超文本传输协议传输数据。</p><h2 id="http模块的基本使用"><a href="#http模块的基本使用" class="headerlink" title="http模块的基本使用"></a><code>http</code>模块的基本使用</h2><p>使用步骤：</p><ul><li>导入<code>http</code>模块</li><li>创建服务对象</li><li>监听端口，启动服务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务对象 server ，传入的回调函数在接收到请求报文时执行</span></span><br><span class="line"><span class="comment">// 其中req、res分别是请求报文和响应报文的封装对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello HTTP server&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听端口, 启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running at port9000&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：浏览器输入：<code>http://127.0.0.1:9000</code>即可看到响应内容。</p><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-24%20110053.png"></p><p>说明：</p><ul><li>修改代码，需要重新启动服务，或者安装<code>nodemon</code>命令行工具</li><li>若响应内容中包含了中文，会出现乱码的结果，可通过设置响应头来解决。<code>res.setHeader(&#39;content-type&#39;, &#39;text/html;charset=utf-8&#39;)</code></li><li><code>HTTP</code>协议的默认端口号是80，<code>HTTPS</code>协议的默认端口号是443。</li><li>若端口被占用，可更改其他端口或者关闭正在监听端口的服务。</li></ul><h2 id="浏览器查看请求"><a href="#浏览器查看请求" class="headerlink" title="浏览器查看请求"></a>浏览器查看请求</h2><p><img src="https://cdn.jsdelivr.net/gh/ianlee5645/BlogImages@main/img/http02.png"></p><p>右键检查，选择<em>网络</em>，点击想要查看的请求，就能看到对应的请求报文和响应报文了。</p><h2 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h2><p><code>req</code>对象上封装了许多属性，可以用来获取对应的数据。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>req.method</code></td><td>请求方法</td></tr><tr><td><code>req.httpVersion</code></td><td><code>http</code>版本</td></tr><tr><td><code>req.url</code></td><td>请求路径</td></tr><tr><td><code>req.headers</code></td><td>请求头</td></tr></tbody></table><p>还可以借助<code>url</code>模块来获取路径和查询字符串：</p><p><code>URL路径：require(&#39;url&#39;).parse(req.url).pathname</code></p><p><code>URL查询字符串：require(&#39;url&#39;).parse(req.url, true).query</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(req.<span class="property">url</span>));</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&quot;Hello http&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server is running at port9000&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器地址输入：http://127.0.0.1:9000/search?k=h5，输出如下:</span></span><br><span class="line"><span class="title class_">Url</span> &#123;</span><br><span class="line">  <span class="attr">protocol</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">slashes</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">auth</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">host</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">hostname</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">hash</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">search</span>: <span class="string">&#x27;?k=h5&#x27;</span>,</span><br><span class="line">  <span class="attr">query</span>: <span class="string">&#x27;k=h5&#x27;</span>,</span><br><span class="line">  <span class="attr">pathname</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/search?k=h5&#x27;</span>,</span><br><span class="line">  <span class="attr">href</span>: <span class="string">&#x27;/search?k=h5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置响应报文"><a href="#设置响应报文" class="headerlink" title="设置响应报文"></a>设置响应报文</h2><p><code>res</code>身上同样封装有属性和方法，用来操作响应报文。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>res.statusCode</code></td><td>设置响应状态码</td></tr><tr><td><code>res.statusMessage</code></td><td>设置响应状态信息</td></tr><tr><td><code>res.setHeader(key, value)</code></td><td>设置响应头字段</td></tr><tr><td><code>res.write(xxx)/res.end(xxx)</code></td><td>设置响应体</td></tr></tbody></table><p>说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write 和 end 的区别：</span></span><br><span class="line"><span class="comment">// write可以设置多次响应体，最后end返回</span></span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">write</span>(<span class="string">&#x27;xx&#x27;</span>);</span><br><span class="line">response.<span class="title function_">end</span>(); <span class="comment">//每一个请求，在处理的时候必须要执行 end 方法的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独使用 end 方法 一次性设置响应体</span></span><br><span class="line">response.<span class="title function_">end</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源是指内容长时间不发生改变的资源 ，例如图片，视频，<code>CSS</code> 文件，<code>JS</code>文件，<code>HTML</code>文件，字体文件等，一般存放在根目录下的<code>public</code>文件夹内。</p><p>动态资源是指内容经常更新的资源。</p><h3 id="网页URL"><a href="#网页URL" class="headerlink" title="网页URL"></a>网页URL</h3><p>网页当中会使用大量的URL，例如<code>a</code>标签的<code>href</code>属性、<code>link</code>标签的<code>href</code>属性、<code>script</code>标签的<code>src</code>属性等等</p><p>在指定URL的时候，有两种选择：绝对路径和相对路径。</p><p><strong>绝对路径</strong>可靠性强，而且相对容易理解，在项目中运用较多。</p><table><thead><tr><th>形式</th><th>解释</th></tr></thead><tbody><tr><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td></tr><tr><td>&#x2F;&#x2F;baidu.com</td><td>与页面 URL 的协议拼接形成完整 URL 再发送请求。大型网站用的比较多</td></tr><tr><td>&#x2F;search</td><td>与页面 URL 的协议、主机名、端口拼接形成完整 URL 再发送请求。中小 型网站</td></tr></tbody></table><p><strong>相对路径</strong>在发送请求时，需要与当前页面 URL 路径进行 计算 ，得到完整 URL 后，再发送请求。</p><p>假设当前网页url为：<code>http://localhost/public/index.html</code></p><table><thead><tr><th>形式</th><th>完整</th></tr></thead><tbody><tr><td><code>/css/app.css </code></td><td><code>http://localhost/public/css/app.css</code></td></tr><tr><td><code>js/app.js</code></td><td><code>http://localhost/public/js/app.js</code></td></tr><tr><td><code>../img/logo.png </code></td><td><code>http://localhost/img/logo.png</code></td></tr><tr><td><code>../../mp4/show.mp4 </code></td><td><code>http://localhost/mp4/show.mp4</code></td></tr></tbody></table><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p>媒体类型（Multipurpose Internet Mail Extensions），也称<code>MIME</code>类型，用来表示文档、文件或字节流的性质和格式。</p><p>格式：<code>[type]/[subType]</code></p><p>设置：HTTP服务通过设置响应头<code>Content-Type</code>来指定。</p><p>常见的<code>MIME</code>类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html: &#x27;text/html&#x27;,</span><br><span class="line">css: &#x27;text/css&#x27;,</span><br><span class="line">js: &#x27;text/javascript&#x27;,</span><br><span class="line">png: &#x27;image/png&#x27;,</span><br><span class="line">jpg: &#x27;image/jpeg&#x27;,</span><br><span class="line">gif: &#x27;image/gif&#x27;,</span><br><span class="line">mp4: &#x27;video/mp4&#x27;,</span><br><span class="line">mp3: &#x27;audio/mpeg&#x27;,</span><br><span class="line">json: &#x27;application/json&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的http模块。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章带你学会SVG</title>
    <link href="http://ianblog.top/posts/5b54a0db.html"/>
    <id>http://ianblog.top/posts/5b54a0db.html</id>
    <published>2023-05-17T12:36:20.000Z</published>
    <updated>2023-10-05T07:48:08.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>SVG</code>是 Web 应用中常用的表示图片的方式。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>是一种基于 XML 语法的图像格式，全称是可缩放适量图。</p><p>特点是不管放大多少倍都不会<strong>失真</strong>。</p><p>SVG 文件可以直接插入网页，成为 DOM 的一部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SVG 代码也可以写在一个独立文件中，使用<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;iframe&gt;</code>等标签插入网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;circle.svg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">&quot;object&quot;</span> <span class="attr">data</span>=<span class="string">&quot;circle.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">id</span>=<span class="string">&quot;embed&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 也能使用 SVG 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">icon.svg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVG 还能转为 BASE64 编码，然后作为 Data URI 写入网页</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/svg+xml;base64,[data]&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标签"><a href="#标签" class="headerlink" title="&lt;svg&gt;标签"></a><code>&lt;svg&gt;</code>标签</h2><p>SVG 代码放在顶层标签<code>&lt;svg&gt;</code>之中</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述例子中：<code>width</code>、<code>height</code>指定 SVG 图像在 HTML 元素中所占据的宽度和高度。可使用相对或者绝对单位。不指定的话，则是 300px × 150px。如果只想展示 SVG 图像的一部分，则可以指定<code>viewBox</code>属性。该属性分别表示左上角的横坐标和纵坐标、视口的宽度和高度。视口必须适配所在的空间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;circle&gt;标签"></a><code>&lt;circle&gt;</code>标签</h2><p><code>&lt;circle&gt;</code>标签代表圆形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;30&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;90&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fancy&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码指定了三个圆。<code>cx</code>、<code>cy</code>、<code>r</code>属性分别表示横坐标、纵坐标和半径，单位为像素。相对于<code>&lt;svg&gt;</code>画布的左上角原点。<code>class</code>属性用来指定对应的 CSS 类。</p><p>SVG 的 CSS 属性与网页元素有所不同：</p><ul><li>fill：填充色</li><li>stroke：描边色</li><li>stroke-width：边框宽度</li></ul><h2 id="标签-2"><a href="#标签-2" class="headerlink" title="&lt;line&gt;标签"></a><code>&lt;line&gt;</code>标签</h2><p><code>&lt;line&gt;</code>标签用来绘制直线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">line</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;stroke:rgb(0,0,0);stroke-width:5&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x1</code>、<code>y1</code>、<code>x2</code>、<code>y2</code>属性分别表示线段的起始和终止坐标；<code>style</code>属性表示线段的样式。</p><h2 id="标签-3"><a href="#标签-3" class="headerlink" title="&lt;polyline&gt;标签"></a><code>&lt;polyline&gt;</code>标签</h2><p><code>&lt;polyline&gt;</code>标签用于绘制一根折线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polyline</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&quot;60 110 65 120 70 115 75 130 80 125 85 140 90 135 95 150 100 145&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">&quot;transparent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>points</code>属性指定每个端点的坐标。</p><h2 id="标签-4"><a href="#标签-4" class="headerlink" title="&lt;rect&gt;标签&gt;"></a><code>&lt;rect&gt;</code>标签&gt;</h2><p><code>&lt;rect&gt;</code>标签用于绘制矩形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;stroke: #70d5dd; fill: #dd524b&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x</code>、<code>y</code>属性分别表示左上角端点的横坐标和纵坐标；<code>width</code>、<code>height</code>属性指定了矩形的宽度和高度。</p><h2 id="标签-5"><a href="#标签-5" class="headerlink" title="&lt;ellipse&gt;标签"></a><code>&lt;ellipse&gt;</code>标签</h2><p><code>&lt;ellipse&gt;</code>标签用于绘制椭圆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ellipse</span></span></span><br><span class="line"><span class="tag">    <span class="attr">cx</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ry</span>=<span class="string">&quot;40&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rx</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">&quot;silver&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>cx</code>、<code>cy</code>属性，指定了椭圆中心的横坐标和纵坐标；<code>rx</code>、<code>ry</code>属性指定了椭圆横向轴和纵向轴的半径。</p><h2 id="标签-6"><a href="#标签-6" class="headerlink" title="&lt;polygon&gt;标签"></a><code>&lt;polygon&gt;</code>标签</h2><p><code>&lt;polygon&gt;</code>标签用于绘制多边形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">points</span>=<span class="string">&quot;0,0 100,0 100,100 0,100 0,0&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>points</code>属性指定每个端点的坐标。</p><h2 id="标签-7"><a href="#标签-7" class="headerlink" title="&lt;path&gt;标签"></a><code>&lt;path&gt;</code>标签</h2><p><code>&lt;path&gt;</code>标签用于绘制路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">d</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  M 18,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 61,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 32,68</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 3,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 18,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  Z</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>d</code>属性表示绘制顺序，值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M：移动到 moveto</span><br><span class="line">L；画直线到 lineto</span><br><span class="line">Z：闭合路径</span><br></pre></td></tr></table></figure><h2 id="标签-8"><a href="#标签-8" class="headerlink" title="&lt;text&gt;标签"></a><code>&lt;text&gt;</code>标签</h2><p><code>&lt;text&gt;</code>标签用于绘制文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;25&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>x</code>、<code>y</code>属性表示文本区块基线起点的横坐标和纵坐标。样式可以用<code>class</code>、<code>style</code>属性指定。</p><h2 id="标签-9"><a href="#标签-9" class="headerlink" title="&lt;use&gt;标签"></a><code>&lt;use&gt;</code>标签</h2><p><code>&lt;use&gt;</code>标签用于复制一个形状</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 30 10&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;5&quot;</span> <span class="attr">r</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>href</code>属性指定所要复制的节点，<code>x</code>、<code>y</code>属性是左上角的坐标。还可以指定<code>width</code>、<code>height</code>属性。</p><h2 id="标签-10"><a href="#标签-10" class="headerlink" title="&lt;g&gt;标签"></a><code>&lt;g&gt;</code>标签</h2><p><code>&lt;g&gt;</code>标签用于将多个形状组成一个组（group），方便复用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>id</code>指定了组的 ID</p><h2 id="标签-11"><a href="#标签-11" class="headerlink" title="&lt;defs&gt;标签"></a><code>&lt;defs&gt;</code>标签</h2><p><code>&lt;defs&gt;</code>标签用于自定义形状，它的内部代码不会显示，仅供引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;#myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-12"><a href="#标签-12" class="headerlink" title="&lt;pattern&gt;标签"></a><code>&lt;pattern&gt;</code>标签</h2><p><code>&lt;pattern&gt;</code>标签用于自定义一个形状，该形状可以被引用来平铺一个区域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;dots&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">patternUnits</span>=<span class="string">&quot;userSpaceOnUse&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span> <span class="attr">fill</span>=<span class="string">&quot;#bee9e8&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;35&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#dots)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;pattern&gt;</code>标签将一个圆形定义为<code>dots</code>模式。<code>patternUnits=&quot;userSpaceOnUse&quot;</code>表示<code>&lt;pattern&gt;</code>的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形。</p><h2 id="标签-13"><a href="#标签-13" class="headerlink" title="&lt;image&gt;标签"></a><code>&lt;image&gt;</code>标签</h2><p><code>&lt;image&gt;</code>标签用于插入图片文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">image</span> <span class="attr">xlink:href</span>=<span class="string">&quot;path/to/image.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;image&gt;</code>的<code>xlink:href</code>属性表示图像的来源。</p><h2 id="标签-14"><a href="#标签-14" class="headerlink" title="&lt;animate&gt;标签"></a><code>&lt;animate&gt;</code>标签</h2><p><code>&lt;animate&gt;</code>标签用于产生动画效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#feac5e&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span></span></span><br><span class="line"><span class="tag">      <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">from</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">to</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，矩形会不断移动，产生动画效果。</p><p><code>&lt;animate&gt;</code>属性含义如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attributeName；发生动画效果的属性名</span><br><span class="line">from：单次动画的初始值</span><br><span class="line">to；单次动画的结束值</span><br><span class="line">dur：单次动画的持续时间</span><br><span class="line">repeatCount：动画的循环模式</span><br></pre></td></tr></table></figure><p>可以在多个属性上面定义动画。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animate</span></span></span><br><span class="line"><span class="tag">  <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">from</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">to</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;width&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签-15"><a href="#标签-15" class="headerlink" title="&lt;animateTransform&gt;标签"></a><code>&lt;animateTransform&gt;</code>标签</h2><p><code>&lt;animate&gt;</code>标签对 CSS 的<code>transform</code>属性不起作用，如果需要变形，就要使用<code>&lt;animateTransform&gt;</code>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;250&quot;</span> <span class="attr">y</span>=<span class="string">&quot;250&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#4bc0c8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animateTransform</span></span></span><br><span class="line"><span class="tag">      <span class="attr">attributeName</span>=<span class="string">&quot;transform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;rotate&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">begin</span>=<span class="string">&quot;0s&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">dur</span>=<span class="string">&quot;10s&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">from</span>=<span class="string">&quot;0 200 200&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">to</span>=<span class="string">&quot;360 400 400&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;animateTransform&gt;</code>的效果为旋转（<code>rotate</code>），这时<code>from</code>和<code>to</code>属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标。<code>from=&quot;0 200 200&quot;</code>表示开始时，角度为 0，围绕<code>(200, 200)</code>开始旋转；<code>to=&quot;360 400 400&quot;</code>表示结束时，角度为 360，围绕<code>(400, 400)</code>旋转。</p><h1 id="JavaScript-操作"><a href="#JavaScript-操作" class="headerlink" title="JavaScript 操作"></a>JavaScript 操作</h1><h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><p>如果<code>SVG</code>代码直接写在 HTML 网页之中，它就成为网页 DOM 的一部分，可以直接用 DOM 操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">circle &#123;</span><br><span class="line">  stroke-<span class="attribute">width</span>: <span class="number">5</span>;</span><br><span class="line">  stroke: <span class="number">#f00</span>;</span><br><span class="line">  fill: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circle<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  stroke: <span class="number">#090</span>;</span><br><span class="line">  fill: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mycircle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mycircle&quot;</span>);</span><br><span class="line"></span><br><span class="line">mycircle.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;circle clicked - enlarging&quot;</span>);</span><br><span class="line">    mycircle.<span class="title function_">setAttribute</span>(<span class="string">&quot;r&quot;</span>, <span class="number">60</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="获取SVG-DOM"><a href="#获取SVG-DOM" class="headerlink" title="获取SVG DOM"></a>获取<code>SVG DOM</code></h2><p>使用<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>标签插入 <code>SVG </code>文件，可以获取 <code>SVG DOM</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgObject = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;object&quot;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgIframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;iframe&quot;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgEmbed = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;embed&quot;</span>).<span class="title function_">getSVGDocument</span>();</span><br></pre></td></tr></table></figure><p>注意，如果使用<code>&lt;img&gt;</code>标签插入 <code>SVG</code> 文件，就无法获取 <code>SVG DOM</code>。</p><h2 id="读取SVG源码"><a href="#读取SVG源码" class="headerlink" title="读取SVG源码"></a>读取<code>SVG</code>源码</h2><p>由于<code> SVG</code> 文件就是一段 <code>XML </code>文本，因此可以通过读取 XML 代码的方式，读取 <code>SVG </code>源码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;svg-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xml:space</span>=<span class="string">&quot;preserve&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;440&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- svg code --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>XMLSerializer</code>实例的<code>serializeToString()</code>方法，获取<code>SVG</code>元素的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgString = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>().<span class="title function_">serializeToString</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="SVG图像转为Canvas图像"><a href="#SVG图像转为Canvas图像" class="headerlink" title="SVG图像转为Canvas图像"></a><code>SVG</code>图像转为<code>Canvas</code>图像</h2><p>首先，需要新建一个<code>Image</code>对象，将<code>SVG</code>图像指定到该<code>Image</code>对象的<code>src</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgString = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>().<span class="title function_">serializeToString</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，当图像加载完成后，再将它绘制到<code>&lt;canvas&gt;</code>元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了SVG图片的相关知识。</summary>
    
    
    
    <category term="SVG学习记录" scheme="http://ianblog.top/categories/SVG%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="SVG" scheme="http://ianblog.top/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——path模块</title>
    <link href="http://ianblog.top/posts/cb8d6098.html"/>
    <id>http://ianblog.top/posts/cb8d6098.html</id>
    <published>2023-05-15T01:54:23.000Z</published>
    <updated>2023-09-22T13:29:35.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node</code>中的<code>path</code>内置模块提供了操作路径的功能。·</p></blockquote><p><code>path</code>模块的引入：<code>const path = require(&#39;path&#39;)</code></p><p>下面介绍几个常用的API。</p><h2 id="resolve拼接路径"><a href="#resolve拼接路径" class="headerlink" title="resolve拼接路径"></a><code>resolve</code>拼接路径</h2><p>语法：<code>path.resolve([...paths])</code></p><p>说明：参数paths表示的是多个路径。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./index.html&quot;</span>)); </span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码\index.html 正确的路径分隔符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;index.html&quot;</span>));</span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码\index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;/index.html&quot;</span>));</span><br><span class="line"><span class="comment">// C:\index.html</span></span><br></pre></td></tr></table></figure><h2 id="sep获取系统路径分隔符"><a href="#sep获取系统路径分隔符" class="headerlink" title="sep获取系统路径分隔符"></a><code>sep</code>获取系统路径分隔符</h2><p>语法：<code>path.sep</code></p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取路径分隔符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">sep</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="parse解析路径"><a href="#parse解析路径" class="headerlink" title="parse解析路径"></a><code>parse</code>解析路径</h2><p>语法：<code>path.parse(pathName)</code></p><p>说明：参数<code>pathName</code>表示文件路径</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;C:\\Users\\learn-node\\代码\\index.html&quot;</span>; <span class="comment">// 需要转义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">parse</span>(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   root: &#x27;C:\\&#x27;,</span></span><br><span class="line"><span class="comment">//   dir: &#x27;C:\\Users\\learn-node\\代码&#x27;,</span></span><br><span class="line"><span class="comment">//   base: &#x27;index.html&#x27;,</span></span><br><span class="line"><span class="comment">//   ext: &#x27;.html&#x27;,</span></span><br><span class="line"><span class="comment">//   name: &#x27;index&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="basename-dirname-extname获取路径相关信息"><a href="#basename-dirname-extname获取路径相关信息" class="headerlink" title="basename/dirname/extname获取路径相关信息"></a><code>basename/dirname/extname</code>获取路径相关信息</h2><p>语法：</p><p>基础名称：<code>path.basename()</code></p><p>目录名：<code>path.dirname()</code></p><p>扩展名：<code>path.extname()</code></p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;C:\\Users\\learn-node\\代码\\index.html&quot;</span>; <span class="comment">// 需要转义</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(str)); <span class="comment">// index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(str)); <span class="comment">// C:\Users\learn-node\\代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(str)); <span class="comment">// .htm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的path模块。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly主体魔改记录</title>
    <link href="http://ianblog.top/posts/2c929405.html"/>
    <id>http://ianblog.top/posts/2c929405.html</id>
    <published>2023-05-10T09:28:53.000Z</published>
    <updated>2023-09-22T13:29:35.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文中用于记录Butterfly主题的修改，以便能够快速定位。</p></blockquote><h2 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h2><p>在博客目录打开<code>Git Bush</code>，输入<code>hexo new page tags</code></p><p>找到<code>source/tags/index.md</code>文件，修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h2><p>在博客目录打开<code>Git Bush</code>，输入<code>hexo new page categories</code></p><p>找到<code>source/categories/index.md</code>文件，修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>在项目中打开终端，输入<code>npm install hexo-generator-search --save</code></p><p>在<code>_config.butterfly.yml</code>文件夹中，找到<code>local_search</code>，并修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Local search</span></span><br><span class="line">local<span class="emphasis">_search:</span></span><br><span class="line"><span class="emphasis">  enable: true</span></span><br><span class="line"><span class="emphasis">  # Preload the search data when the page loads.</span></span><br><span class="line"><span class="emphasis">  preload: false</span></span><br><span class="line"><span class="emphasis">  # Show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="emphasis">  top_</span>n<span class="emphasis">_per_</span>article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  CDN:</span><br><span class="line">  labels:</span><br><span class="line"><span class="code">    input_placeholder: Search for Posts</span></span><br><span class="line"><span class="code">    hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure><h2 id="live2d效果"><a href="#live2d效果" class="headerlink" title="live2d效果"></a>live2d效果</h2><p>在项目中打开终端，输入<code>hexo-helper-live2d--save</code>，然后安装一个你想要的模型，笔者安装的是<code>npm install live2d-widget-model-wanko --save</code>。</p><p><a href="https://github.com/xiazeyu/live2d-widget-models">模型地址</a></p><p>然后在<code>_config.yml</code>文件中添加：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#live2d</span></span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptForm: local</span><br><span class="line">  model:</span><br><span class="line"><span class="code">    use: live2d-widget-model-wanko #模型选择</span></span><br><span class="line"><span class="code">  display:</span></span><br><span class="line"><span class="code">    position: right</span></span><br><span class="line"><span class="code">    width: 180</span></span><br><span class="line"><span class="code">    height: 180</span></span><br><span class="line"><span class="code">    hOffset: 30</span></span><br><span class="line"><span class="code">    vOffset: -10</span></span><br><span class="line"><span class="code">  mobile:</span></span><br><span class="line"><span class="code">    show: false</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>enable</td><td>是否开启live2d</td></tr><tr><td>use</td><td>使用的模型</td></tr><tr><td>position</td><td>位置</td></tr><tr><td>width、height</td><td>模型大小</td></tr><tr><td>hOffset、vOffset</td><td>偏移量</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文记录了Hexo主题Butterfly的魔改。</summary>
    
    
    
    <category term="Hexo 主题魔改" scheme="http://ianblog.top/categories/Hexo-%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/"/>
    
    
    <category term="Hexo" scheme="http://ianblog.top/tags/Hexo/"/>
    
    <category term="Blog" scheme="http://ianblog.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——fs模块</title>
    <link href="http://ianblog.top/posts/95529e13.html"/>
    <id>http://ianblog.top/posts/95529e13.html</id>
    <published>2023-05-07T07:14:13.000Z</published>
    <updated>2023-09-22T06:49:56.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>的<code>fs</code>模块能够与文件系统进行交互。</p></blockquote><h2 id="fs模块介绍"><a href="#fs模块介绍" class="headerlink" title="fs模块介绍"></a><code>fs</code>模块介绍</h2><p><code>fs（File System）</code>是<code>Node.js</code>的内置模块，可以实现与硬盘的交互，例如文件的创建、删除、重命名、移动，以及文件的写入与读取。</p><p><code>fs</code>模块中的方法有同步与异步之分。</p><p>下面我将介绍<code>fs</code>模块的基本操作：</p><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>将数据保存到文件中，我们平常下载文件、安装软件的时候，就是将文件写入了磁盘中。</p><h3 id="1-writeFile异步写入"><a href="#1-writeFile异步写入" class="headerlink" title="1. writeFile异步写入"></a>1. <code>writeFile</code>异步写入</h3><p>语法：<code>fs.writeFile(file, data[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>data</code></td><td>待写入的数据</td></tr><tr><td><code>options</code></td><td>配置选项</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello Node.js&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 失败传入错误对象，成功传入null</span></span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)；</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-writeFileSync同步写入"><a href="#2-writeFileSync同步写入" class="headerlink" title="2.writeFileSync同步写入"></a>2.<code>writeFileSync</code>同步写入</h3><p>语法：<code>fs.writeFile(file, data[, options])</code></p><p>说明：参数部分与异步写入一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于没有回调函数，所以使用try catch来捕获错误</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;hello, Node.js&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-appendFile-appendFileSync追加写入"><a href="#3-appendFile-appendFileSync追加写入" class="headerlink" title="3. appendFile/appendFileSync追加写入"></a>3. <code>appendFile/appendFileSync</code>追加写入</h3><p>同样分为同步追加写入和异步追加写入。</p><p>语法：</p><p><code>fs.appendFile(file, data[, options], callback)</code></p><p><code>fs.appendFileSync(file, data[, options])</code></p><p>说明：参数部分与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加失败&#x27;</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追加成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>,<span class="string">&#x27;\r\nhello&#x27;</span>); <span class="comment">// \r\n换行操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-creatWriteStream流式写入"><a href="#4-creatWriteStream流式写入" class="headerlink" title="4. creatWriteStream流式写入"></a>4. <code>creatWriteStream</code>流式写入</h3><p>语法：<code> fs.createWriteStream(path[, options])</code></p><p>说明：参数含义仍然一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>); <span class="comment">// 创建写入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次写入操作</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方塘一鉴开\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;为有源头活水来\r\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ws.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>对比：流式写入方式适用于 <strong>大文件写入</strong>或者<strong>频繁写入</strong> 的场景, <code>writeFile </code>适合于 写入频率较低的场景</p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>从文件中读取数据，平时电脑开机、程序运行、播放视频、查看图片都是在读取文件。</p><h3 id="1-readFile异步读取"><a href="#1-readFile异步读取" class="headerlink" title="1. readFile异步读取"></a>1. <code>readFile异步读取</code></h3><p>语法：<code> fs.readFile(path[, options], callback)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>file</code></td><td>指定文件路径</td></tr><tr><td><code>options</code></td><td>配置对象</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以utf-8字符集读取</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>) </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-readFileSync同步读取"><a href="#2-readFileSync同步读取" class="headerlink" title="2.readFileSync同步读取"></a>2.<code>readFileSync同步读取</code></h3><p>语法：<code> fs.readFileSync(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> data2 = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-creatReadStream流式读取"><a href="#3-creatReadStream流式读取" class="headerlink" title="3. creatReadStream流式读取"></a>3. <code>creatReadStream流式读取</code></h3><p>语法：<code> fs.createReadStream(path[, options])</code></p><p>说明：参数与上述方法基本一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次取出 64k 数据后执行一次 data 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">length</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取完毕后, 执行 end 回调</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件重命名与移动"><a href="#文件重命名与移动" class="headerlink" title="文件重命名与移动"></a>文件重命名与移动</h2><h3 id="rename-renameSync"><a href="#rename-renameSync" class="headerlink" title="rename/renameSync"></a><code>rename/renameSync</code></h3><p>语法：</p><p><code>fs.rename(oldPath, newPath, callback)</code></p><p><code>fs.renameSync(oldPath, newPath)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>oldPath</code></td><td>当前路径</td></tr><tr><td><code>newPath</code></td><td>新的路径</td></tr><tr><td><code>callback</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;./abc.txt&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span>&#123; <span class="comment">// 重命名</span></span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">renameSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="string">&#x27;../code/text.txt&#x27;</span>); <span class="comment">// 移动</span></span><br></pre></td></tr></table></figure><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p>将文件从当前目录移除。</p><h3 id="1-unlink-unlinkSync"><a href="#1-unlink-unlinkSync" class="headerlink" title="1.unlink/unlinkSync"></a>1.<code>unlink/unlinkSync</code></h3><p>语法：</p><p><code>fs.unlink(path, callback)</code></p><p><code>fs.unlinkSync(path)</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>path</td><td>文件路径</td></tr><tr><td>callback</td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-rm"><a href="#2-rm" class="headerlink" title="2.rm"></a>2.<code>rm</code></h3><p>语法：<code>fs.rm(path, callback)</code></p><p>参数：与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&quot;./text.txt&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作文件夹"><a href="#操作文件夹" class="headerlink" title="操作文件夹"></a>操作文件夹</h2><h3 id="1-mkdir-mkdirSync创建文件夹"><a href="#1-mkdir-mkdirSync创建文件夹" class="headerlink" title="1. mkdir/mkdirSync创建文件夹"></a>1. <code>mkdir/mkdirSync创建文件夹</code></h3><p>语法：</p><p><code>fs.mkdir(path[, options], callback)</code></p><p><code>fs.mkdirSync(path[, options])</code></p><p>说明：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>path</code></td><td>文件夹路径</td></tr><tr><td><code>options</code></td><td>配置对象</td></tr><tr><td><code>callbak</code></td><td>回调函数</td></tr></tbody></table><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./page&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套文件夹创建--需要配置</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a/b/c&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;递归创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(<span class="string">&#x27;./x/y/z&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-readdir-readdirSync读取文件夹"><a href="#2-readdir-readdirSync读取文件夹" class="headerlink" title="2. readdir/readdirSync读取文件夹"></a>2. <code>readdir/readdirSync读取文件夹</code></h3><p>语法：</p><p><code>fs.readdir(path[, options], callback)</code></p><p><code>fs.readdirSync(path[, options])</code></p><p>说明：参数与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步读取</span></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./text&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 输出是个包含文件名称数组</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步读取</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readdirSync</span>(<span class="string">&#x27;./text&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure><h3 id="3-rm-rmdir删除文件夹"><a href="#3-rm-rmdir删除文件夹" class="headerlink" title="3. rm/rmdir删除文件夹"></a>3. <code>rm/rmdir删除文件夹</code></h3><p>语法：</p><p><code>fs.rm(path[, options], callback)</code></p><p><code>fs.rmdir(path[, options], callback)</code></p><p>说明：参数与上述方法一致。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套（递归）删除</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&quot;./a&quot;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span>, <span class="attr">force</span>: <span class="literal">true</span> &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&quot;./a&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移除成功&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：<code>rmdir</code>也能递归删除文件夹，但是<code>recursive</code>配置已经废弃了，所以不推荐使用。</p><h2 id="stat-statSync查看资源状态"><a href="#stat-statSync查看资源状态" class="headerlink" title="stat/statSync查看资源状态"></a><code>stat/statSync</code>查看资源状态</h2><p>语法：</p><p><code>fs.stat(path[, options], callback) </code></p><p><code>fs.statSync(path[, options])</code></p><p>说明：参数含义同上。</p><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步获取状态</span></span><br><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;./text.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查看失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">  <span class="comment">// 输出是个对象 &#123;size: xxx, birthtime: xxx, mtime: xxx, isFile: xxx, ...&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//同步获取状态</span></span><br><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">statSync</span>(<span class="string">&#x27;./text.txt&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>上述方法的第一个参数的都是指文件的路径，而文件的路径有两种写法：</p><ul><li>相对路径：<code>./a.txt</code>（当前目录下）、<code>a.text</code>（当前目录下）、<code>../a.txt</code>（上一级目录下）</li><li>绝对路径：<code>C:/a.txt</code>、<code>/a.txt</code></li></ul><p>说明：相对路径是指相对<strong>命令行的工作目录</strong>，而<em>非文件所在的目录</em>。所以在不同目录下执行文件，会出现一些问题。要想解决这个问题，要么使用绝对路径，要么使用<code>__dirname</code>（这个变量始终保存当前文件所在目录的绝对路径）拼接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/text.txt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname + <span class="string">&#x27;/text.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// C:\Users\learn-node\代码/text.txt 拼接的符号不同</span></span><br></pre></td></tr></table></figure><p>当然，与<code>path</code>模块搭配使用，可以生成更加正确的路径。而且也推荐与<code>path</code>搭配使用。</p><p>nice！😀！下一篇我们将学习<code>path</code>模块！！</p>]]></content>
    
    
    <summary type="html">本文介绍了Node.js中的fs模块。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js——介绍</title>
    <link href="http://ianblog.top/posts/c222fd29.html"/>
    <id>http://ianblog.top/posts/c222fd29.html</id>
    <published>2023-05-05T08:15:14.000Z</published>
    <updated>2023-09-22T04:37:32.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Node.js</code>使<code>JavaScript</code>具有服务端开发的能力。</p></blockquote><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是<code>Node.js</code></h2><blockquote><p><code>Node.js</code>官方给出的定义是：</p><p><code>Node.js</code>® is an open-source, cross-platform JavaScript runtime environment.</p></blockquote><p>意思是：<code>Node.js</code>是一个开源的，跨平台的<code>JavaScript</code>运行环境。通俗地说，<code>Node.js</code>其实就是一款应用程序，能够运行<code>JavaScript</code>。</p><p>Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。</p><p><a href="https://nodejs.org/en">下载<code>Node.js</code> </a>，推荐安装LTS（长期支持版本）</p><p>检测是否下载成功，在命令行中输入<code>node -v</code>，如果显示出版本号了，则说明安装成功。</p><h2 id="Node-js的作用"><a href="#Node-js的作用" class="headerlink" title="Node.js的作用"></a><code>Node.js</code>的作用</h2><ol><li>开发服务器应用</li><li>开发工具类应用（<code>Webpack</code>、<code>Vite</code>、<code>Babel</code>）</li><li>开发桌面端应用（<code>VScode</code>、<code>Figma</code>、<code>Postman</code>都是借助<code>electron</code>开发的）</li></ol><h2 id="Node-js的使用"><a href="#Node-js的使用" class="headerlink" title="Node.js的使用"></a><code>Node.js</code>的使用</h2><p>使用<code>Node.js</code>运行<code>JavaScript</code>代码：</p><ol><li>在你的代码目录中新建一个文件<code>hello.js</code>，输入<code>console.log(&quot;hello, Node.js&quot;)</code>，保存。</li><li>然后打开<code>VScode</code>终端（如果你的代码编辑器是<code>VScode</code>的话），输入<code>node hello.js</code>。或者你也可以直接打开<code>cmd</code>，只不过需要切换为文件所在目录。</li><li>终端上显示<code>hello, Node.js</code>。</li></ol><p>注意点：</p><ul><li><code>Node.js</code>中的<code>API</code>与浏览器中的<code>API</code>有所区别，重点是不能在<code>Node.js</code>中使用<code>DOM</code>、<code>BOM</code> （如果你在<code>Node.js</code>中输出<code>window</code>对象或者<code>document</code>对象的话，会报错）。</li><li><code>Node.js</code>当中的顶级对象是<code>global</code>或者<code>globalThis</code>（<code>ES2020</code>定义）。</li><li><code>Nodde.js</code>使用的是<code>CommonJS</code>模块，所以导入模块方式为<code>const xxx = require(&#39;xxx&#39;)</code>。</li></ul>]]></content>
    
    
    <summary type="html">本文简单介绍了Node.js。</summary>
    
    
    
    <category term="Node.js学习记录" scheme="http://ianblog.top/categories/Node-js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://ianblog.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议——首部</title>
    <link href="http://ianblog.top/posts/b494c766.html"/>
    <id>http://ianblog.top/posts/b494c766.html</id>
    <published>2023-04-25T10:16:19.000Z</published>
    <updated>2023-09-23T07:53:02.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP协议的请求和响应报文中必定包含HTTP首部。本文基于图书《图解HTTP》。</p></blockquote><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>在正式介绍HTTP首部之前，我们先看一下HTTP报文的结构：</p><p>HTTP报文由报文首部、空行（CR+LF）以及报文主体组成。请求报文的首部由请求行和请求头（请求首部字段）组成；响应报文的首部由响应行和响应头（响应首部字段组成）。</p><p>请求报文示例：请求行由方法、请求URI、协议版本构成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>abc.com</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-cn,en</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>响应报文示例：响应行由协议版本、响应状态码、响应状态字符串构成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu, 07 Jun 2012 07:21:36 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><p>从上面的示例可以看出：首部字段由首部字段名和字段值构成，中间用<code>：</code>分隔。</p><p>HTTP首部字段根据实际用途被分为4种类型：</p><ul><li><strong>通用首部字段</strong>：请求报文和响应报文都会使用的首部。</li><li><strong>请求首部字段</strong>：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li><strong>响应首部字段</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li><li><strong>实体首部字段</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li></ul><p>下面我将逐一介绍（以下的首部由HTTP1.1规范定义）：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>作用：用来控制缓存的工作机制。</p><p>使用：<code>cache-control: private, max-age=0, no-cache</code></p><p>字段值如下：</p><p>缓存请求指令：</p><table><thead><tr><th>字段值</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>强制向源服务器再次验证</td></tr><tr><td>no-store</td><td>不缓存请求或 响应的的任何内容</td></tr><tr><td>max-age&#x3D;[秒]</td><td>响应的最大的Age值</td></tr><tr><td>max-stale(&#x3D;[秒])</td><td>接收已过期的响应</td></tr><tr><td>mix-fresh&#x3D;[秒]</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>新指令标记（token）</td></tr></tbody></table><p>缓存响应指令：</p><table><thead><tr><th>字段值</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>不缓存请求或 响应的的任何内容</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>max-age&#x3D;[秒]</td><td>响应的最大Age值</td></tr><tr><td>s-maxage&#x3D;[秒]</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td>新指令标记（token）</td></tr></tbody></table><p>注意：<code>no-cache</code>代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，而<code>no-store</code>才是真正表示不进行缓存。另外<code>max-age</code>表示的是缓存的最长时间。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>作用：用来控制不再转发给代理的首部字段；用来管理持久连接。</p><p>使用：<code>Connection: Upgrade</code>   <code>Connection: Keep-Alive</code></p><p>说明：HTTP&#x2F;1.1版本默认是持久连接，所以服务器端想要明确断开连接，可以指定<code>Connection</code>的值为<code>close</code>。</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>作用：表明创建HTTP报文的日期和时间。</p><p>使用：<code>Date: Tue, 03 Jul 2023 13:40:59 GMT</code></p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>作用：提示报文主体后记录的首部字段，可应用在HTTP&#x2F;1.1版本分块传输编码时。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Trailer</span><span class="punctuation">: </span>Expires</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="language-apache"><span class="attribute">Expires</span>: Tue, <span class="number">03</span> Jul <span class="number">2023</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">59</span> GMT</span></span><br></pre></td></tr></table></figure><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>作用：规定了传输报文主体时采用的编码方式。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">...</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli">cf0</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...3312</span>字节分块数据<span class="string">...</span></span></span><br><span class="line"><span class="language-jboss-cli">392</span></span><br><span class="line"><span class="language-jboss-cli"><span class="string">...914</span>字节分块数据<span class="string">...</span></span></span><br><span class="line"><span class="language-jboss-cli">0</span></span><br></pre></td></tr></table></figure><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>作用：用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。</p><p>使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>TLS/1.0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br></pre></td></tr></table></figure><p>说明：此时服务器会相应状态码为101 Switching Protocols的响应。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>作用：追踪客户端和服务器之间的请求和响应报文的传输路径以及避免请求回环的发生。</p><p>说明：报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后进行转发。</p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>作用：告知服务器，请求的资源所处的互联网主机名和端口号。</p><p>使用：<code>Host: www.abc.com</code></p><p>说明：因为相同IP地址下有可能部署运行着多个域名，所以需要Host来进行区分。这其实是因为发送请求时，请求中的主机名会用IP地址直接替换解决。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>作用：通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。使用type&#x2F;subtype的形式，一次指定多种媒体类型。</p><p>使用：<code>Accept: text/html,application/xml;q=0.9</code></p><p>说明：q表示权重值，范围为0~1，1表示权重最大。</p><p>常见的媒体类型：<code>text/html、text/plain、text/css、image/jpeg、image/gif、image/png、video/mpeg、video/quicktime</code>。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>作用：用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。</p><p>使用：<code>Accept-Charset: utf-8</code></p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>作用：用来通知服务器用户代理支持的内容编码及内容编码的优先级顺序。</p><p>使用：<code>Accept-Encoding: gzip</code></p><p>内容编码方式有：<code>gzip、compress、deflate、identity</code></p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>作用：告知服务器用户大力能处理的自然语言集。</p><p>使用：<code>Accept-language: zh-cn,zh;q=0.7,en</code></p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4>]]></content>
    
    
    <summary type="html">本文介绍了HTTP协议的常用的HTTP首部。</summary>
    
    
    
    <category term="HTTP协议学习记录" scheme="http://ianblog.top/categories/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="HTTP" scheme="http://ianblog.top/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="http://ianblog.top/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的闭包</title>
    <link href="http://ianblog.top/posts/7ae5b853.html"/>
    <id>http://ianblog.top/posts/7ae5b853.html</id>
    <published>2023-04-23T06:42:36.000Z</published>
    <updated>2023-09-20T02:01:42.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包是<code>Javascript</code>中一个重要的特性，使用闭包可以实现特定的需求，例如函数柯里化等。想要弄懂闭包，首先得要对执行上下文和作用域有足够的了解。</p></blockquote><h1 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h1><p>简单来说，执行上下文就是<code>Javascript</code>代码执行的环境。每个上下文都有一个关联的变量对象，在这个上下文中定义的所有变量和函数都存在于这个变量对象上。</p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul><li><strong>全局上下文</strong> ：最外层的上下文，在浏览器中指的就是<code>window</code>对象，并且用var定义的全局变量和函数会成为<code>window</code>对象的属性和方法。一个程序中只会有一个全局上下文。</li><li><strong>函数上下文</strong> ：每个函数调用都有自己的上下文。函数上下文可以有任意多个。</li><li><strong><code>Eval()</code>调用内部上下文</strong> ：执行在<code>eval</code>函数内部的代码创建属于自己的上下文。</li></ul><p><code>ECAMScript</code> 程序执行流是通过上下文栈来控制的，当代码执行流进入函数时，函数上下文会被推入栈中，当函数执行完毕时，函数上下文会被弹出栈外，将控制权返还给之前的执行上下文。</p><h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>作用域是程序中定义变量的区域，它决定了当前代码对变量的访问权限。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">//  执行函数创建变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>说明：在<code>fn</code> 函数内部创建了一个变量<code>a</code> ，但是在全局访问的时候，系统报错。可见，全局是无法获取函数内部的变量。</p><h2 id="作用域的分类"><a href="#作用域的分类" class="headerlink" title="作用域的分类"></a>作用域的分类</h2><ul><li><p><strong>全局作用域</strong> ：在全局范围内声明的变量（<strong>特殊情况</strong>：在函数中不使用关键字声明变量也会成为全局变量）处于全局作用域下，可以在程序的任意地方访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">display</span>();  <span class="comment">//  打印 0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数作用域</strong> ：也称局部作用域，在函数内部声明的变量处于函数作用域下，不能再函数以外的位置访问（闭包除外）。</p></li><li><p><strong>块级作用域</strong> ：<code>ES6</code>引入的<code>let</code>和<code>const</code> 关键字在大括号中定义的变量处于块级作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  打印 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//  Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><code>JavaScript</code> 遵循的是词法作用域。词法作用域也称静态作用域，是指变量的作用域在创建时就确定好了，而不是执行时才确定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  输出 0</span></span><br></pre></td></tr></table></figure><p>上述代码执行<code>bar</code> 函数，输出的是0，而不是1，说明在<code>bar</code>中调用<code>foo</code> ，函数<code>foo</code> 是访问不到<code>bar</code> 内部的变量。因为<code>foo</code> 处在全局作用域中，而<code>bar</code> 中的变量<code>a</code>是处在函数作用域中。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote><p>在上面，我们知道了处在不同作用域的代码具有不同的访问权限。但是我们还不清楚访问变量是什么样的流程，访问一个变量到底是遵循什么样的规则？当有多个同名的变量可供访问时，选取哪一个？这些问题需要借助作用域链来解决。</p></blockquote><p>上下文中的代码在执行时，会创建变量对象的一个<strong>作用域链</strong>。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。作用域链的顶端（也就是第一个变量对象）<strong>始终</strong>是代码正在执行的上下文，下一个变量对象是来自包含上下文，最后一个变量对象<strong>始终</strong>是全局上下文。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索从顶端开始，逐级往后，直至搜索到标识符，或者搜索到了全局作用域为止。</p><p>看个小例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        <span class="comment">//  这里能访问color,anotherColor,tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  这里能访问color, anotherColor,但是访问不了tempColor</span></span><br><span class="line">    <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><p>上述代码涉及三个上下文，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">|__color</span><br><span class="line">|__changeColor()</span><br><span class="line">  |__anotherColor</span><br><span class="line">  |__swapColors()</span><br><span class="line">    |__tempColor</span><br></pre></td></tr></table></figure><p>内部的上下文可以访问外部上下文的变量和函数，反之不行。</p><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>有两种情况可以增强作用域链，它们都会在作用域的前端添加一个变量对象：</p><ul><li><code>try/catch</code> 语句的<code>catch</code>  块：创建一个新的变量对象，包含要抛出的错误。</li><li><code>with</code> 语句：添加一个指定的对象。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;  <span class="comment">//  块级作用域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">buildUrl</span>();  <span class="comment">//  ReferenceError: url is not defined</span></span><br></pre></td></tr></table></figure><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是指哪些引用了另一个函数作用域中的变量的函数，通常是在嵌套函数中实现的。看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述代码中内部函数的输出语句，引用了外部函数的变量，在这个内部函数被返回并在其他地方调用后，仍然引用着该变量。因为内部函数的作用域链包含了外部函数和全局的变量对象。</p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>闭包能够使函数在其他地方调用时，也能够访问到其外部函数的变量。这使得其在特定场景下具有重要的应用。</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数柯里化是指将一个接收多个参数的函数拆分成多个只接受单个参数的函数。其优势是能够实现参数的复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w, h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">&#125;  <span class="comment">//  求面积，但是需要一直传入宽和高，如果宽固定而高变化，就不能实现复用</span></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">w</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//  柯里化之后，内部返回新的函数只接收高</span></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getTenWidthArea</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="实现私有变量"><a href="#实现私有变量" class="headerlink" title="实现私有变量"></a>实现私有变量</h3><p>使用闭包可以轻松实现私有变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  count += val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter1 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="keyword">const</span> counter2 = <span class="title function_">counter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line">counter1.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  2</span></span><br><span class="line">counter1.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getCount</span>());  <span class="comment">//  1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getCount</span>());  <span class="comment">//  0</span></span><br></pre></td></tr></table></figure><p>上述函数返回包含了特权方法的对象，能够访问函数内部的私有变量以及已有方法。<code>counter1</code> 和<code>counter2</code> 分别维护各自的私有变量，互不影响。</p><p>总的来说，闭包可以延长变量的生命周期。即使外部函数执行完毕返回结果了，其活动变量并不会销毁，因为内部函数的作用域链仍有它的引用。</p><h2 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h2><p>因为闭包会保留它们包含函数额作用域，所以比其他函数更占内存。过渡使用可能导致内存过渡占用。而且在处理速度和内存消耗方面对脚本具有负面影响。因此建议仅在十分必要时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line">bar = <span class="literal">null</span>;  <span class="comment">//  解除对函数的引用，这样就可以释放内存了</span></span><br></pre></td></tr></table></figure><p>Done！😊！</p>]]></content>
    
    
    <summary type="html">本文介绍了JavaScript当中闭包相关的概念</summary>
    
    
    
    <category term="JavaScript进阶" scheme="http://ianblog.top/categories/JavaScript%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JavaScript" scheme="http://ianblog.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
